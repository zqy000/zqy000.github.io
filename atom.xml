<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>将进酒</title>
  <icon>https://www.gravatar.com/avatar/e62f446c6d908d647c2f5e8709ae4de6</icon>
  <subtitle>君不见黄河之水天上来，奔流到海不复回。</subtitle>
  <link href="https://zqy000.github.io/atom.xml" rel="self"/>
  
  <link href="https://zqy000.github.io/"/>
  <updated>2021-08-09T03:30:56.427Z</updated>
  <id>https://zqy000.github.io/</id>
  
  <author>
    <name>ZQY</name>
    <email>zhaiqianyuan@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 学习笔记(1)</title>
    <link href="https://zqy000.github.io/2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://zqy000.github.io/2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>2021-08-09T00:41:51.000Z</published>
    <updated>2021-08-09T03:30:56.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-学习笔记-1"><a href="#Java-学习笔记-1" class="headerlink" title="Java 学习笔记(1)"></a>Java 学习笔记(1)</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        Java最大的优点在于设计之初就秉承了“一次编写，到处运行（Write once,Run Everywhere).”Java语言编写的程序可以在编译后不经任何改动，就能在其他平台上运行，这得益于它的JVM（Java virtual Machine)的机制屏蔽了“翻译”的细节，由JVM负责翻译沟通。</p><p><img src="/images/java1-1.jpg" alt="JVM"></p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        JVM:Java编译器javac将源代码编译成.class文件，然后通过命令java将.class送往Java虚拟机(JVM)最终变成可执行程序。JVM可以看作是在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上提供给编译器一个共同的接口，编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，将这种供虚拟机理解的代码叫做字节码(Byte Code)，他不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机确实相同的。</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE(Java Runtime Environment):JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现以及JAVA核心类库。一个Java程序想要运行在Java虚拟机之中，源代码的语句需要由Java编译器编译成字节码。字节码本质上是一种标准化的可移植的二进制格式。改格式以Java类文件.class的形式存在。一个Java程序可以由多个不同的.class文件构成，通常将多个.class文件打包成一个发布文件.jar。其扩展名来自于”java archive”(java归档文件)的简写。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK(Java Development Kit):Java开发工具包，包括了JRE(Java Runtime Environment)、编译（javac）、解释（java）、打包（jre）等工具还包括开发工具以及开发工具的应用程序接口。</p><h2 id="JAVA基础概念"><a href="#JAVA基础概念" class="headerlink" title="JAVA基础概念"></a>JAVA基础概念</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p></li><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p></li><li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p></li><li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><pre><code class="java">public class HelloWorld &#123;    /* 第一个Java程序     * 它将输出字符串 Hello World     */    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;); // 输出 Hello World    &#125;&#125;</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg"></p></li></ul><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li></ul><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p><h4 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a><strong>Java修饰符</strong></h4><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h4 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a><strong>Java 标识符</strong></h4><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li></ul><h4 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a><strong>Java 变量</strong></h4><p>Java 中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a><strong>Java 数组</strong></h4><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p><h4 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a><strong>Java 枚举</strong></h4><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><h4 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a><strong>Java注释</strong></h4><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。空白行或者有注释的行，Java 编译器都会忽略掉。</p><pre><code class="java">public class HelloWorld &#123;   /* 这是第一个Java程序    * 它将输出 Hello World    * 这是一个多行注释的示例    */    public static void main(String[] args)&#123;       // 这是单行注释的示例       /* 这个也是单行注释的示例 */       System.out.println(&quot;Hello World&quot;);     &#125;&#125;</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h4 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h4><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png"></p><h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><p>Java作为一种面向对象语言。支持以下基本概念：</p><p>​    多态、继承、封装、抽象、类、对象、实例、方法、重载。</p><ul><li><p><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p></li><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p></li></ul><p>汽车为类（class），而具体的每辆车为该<strong>汽车</strong>类的<strong>对象（object）</strong>，对象包含了汽车的颜色、品牌、名称等。</p><p>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/20210105-java-object-1.png"></p><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。static被引入以告知<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>，将变量存储在程序的静态存储区而非栈上空间。static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的存取范围不变。</li></ul><p>类中的static成员：</p><p>一、出现原因及作用：</p><p>1、需要在一个类的各个对象间交互，即需要一个<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">数据对象</a>为整个类而非某个对象服务。</p><p>2、同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。</p><p>类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。</p><p>对于静态的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，注意<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a>嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p>类的静态成员函数是属于整个类而非类的对象，所以它没有this<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，这就导致了它仅能访问类的静态数据和静态成员函数。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法（多态：有参构造、无参构造）。</p><p>下面是一个构造方法示例：</p><pre><code class="java">public class Puppy&#123;    public Puppy()&#123;    &#125;     public Puppy(String name)&#123;        // 这个构造器仅有一个参数：name    &#125;&#125;</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><p>下面是一个创建对象的例子：</p><pre><code class="java">public class Puppy&#123;   public Puppy(String name)&#123;      //这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;   public static void main(String[] args)&#123;      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( &quot;tommy&quot; );   &#125;&#125;</code></pre><h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><pre><code class="java">public class Puppy&#123;   int puppyAge;   public Puppy(String name)&#123;      // 这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;    public void setAge( int age )&#123;       puppyAge = age;   &#125;    public int getAge( )&#123;       System.out.println(&quot;小狗的年龄为 : &quot; + puppyAge );        return puppyAge;   &#125;    public static void main(String[] args)&#123;      /* 创建对象 */      Puppy myPuppy = new Puppy( &quot;tommy&quot; );      /* 通过方法来设定age */      myPuppy.setAge( 2 );      /* 调用另一个方法获取age */      myPuppy.getAge( );      /*你也可以像下面这样访问成员变量 */      System.out.println(&quot;变量值 : &quot; + myPuppy.puppyAge );    &#125;&#125;</code></pre><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><p>类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。</p><p>除了上面提到的几种类型，Java 还有一些特殊的类，如：<a href="https://www.runoob.com/java/java-inner-class.html">内部类</a>、<a href="https://www.runoob.com/java/java-anonymous-class.html">匿名类</a>。</p>]]></content>
    
    
    <summary type="html">Java学习的初级阶段:Java基础语法，类的创建以及使用，基础I/O,循环控制、运算符、数组、方法、方法重载。</summary>
    
    
    
    <category term="Java" scheme="https://zqy000.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://zqy000.github.io/tags/Java/"/>
    
    <category term="学习笔记" scheme="https://zqy000.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基于opencv的视频监控系统</title>
    <link href="https://zqy000.github.io/2020/09/21/%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zqy000.github.io/2020/09/21/%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-21T09:51:49.000Z</published>
    <updated>2021-03-27T15:29:28.555Z</updated>
    
    
    <summary type="html">暂时还未上传，占位而已</summary>
    
    
    
    
    <category term="-占位 -暂无内容 -opencv -c++" scheme="https://zqy000.github.io/tags/%E5%8D%A0%E4%BD%8D-%E6%9A%82%E6%97%A0%E5%86%85%E5%AE%B9-opencv-c/"/>
    
  </entry>
  
  <entry>
    <title>qt5学习笔记(一)</title>
    <link href="https://zqy000.github.io/2020/08/21/qt_learning_1/"/>
    <id>https://zqy000.github.io/2020/08/21/qt_learning_1/</id>
    <published>2020-08-21T09:51:49.000Z</published>
    <updated>2021-03-27T15:29:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初见QT"><a href="#初见QT" class="headerlink" title="初见QT"></a>初见QT</h2><pre><code>        qt的主要模块</code></pre><p>​    <img src="/images/qt1.jpg" alt="image-20210322112141675"></p><p>​                                  创建的项目中的pro文件内容</p><p>.pro基本上是构建工程项目时由Qt处理的第一个文件，这个文件称为Qt项目文件，一个名为“qmake”的内部Qt程序负责处理该文件</p><pre><code class="c++">QT       += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgets //版本大于4以上，使用widgets类，更好的兼容性TARGET = opencv2 //目标  生成的exe可执行文件的名称TEMPLATE = app  //工程所使用的模板DEFINES += QT_DEPRECATED_WARNINGSCONFIG += c++11SOURCES += \                    //源文件        main.cpp \        mainwindow.cppHEADERS += \            //头文件        mainwindow.hFORMS += \                      //ui文件        mainwindow.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target        </code></pre><h3 id="qt命名规范与快捷键"><a href="#qt命名规范与快捷键" class="headerlink" title="qt命名规范与快捷键"></a>qt命名规范与快捷键</h3><p>​    类名：首字母大写 单词与单词之间 首字母大写</p><p>​    函数、变量：首字母小写，单词与单词之间 首字母大写</p><p>快捷键：</p><p>​    运行 ctrl+ R</p><p>​    编译 ctrl + B</p><p>​    查找 ctrl + F</p><p>   帮助文档 第一种: F1 第二种 ：旁边的帮助按钮 第三种：assistant.exe      查看选中类及函数，esc退出</p><p>​    字体缩放 ctrl + 鼠标滚轮</p><p>​    自动对齐 ctrl + i</p><p>​    整行移动 ctrl + shift + 上 或者下</p><p>​    同名之间的 .h  .cpp 切换  F4<br>​    </p><p>使用新类时，要查看该类所属的模块是否包含在工程pro文件中第一行<br>    QT       += core gui network</p><p>show用顶层方式弹出，如果想在MyWidget窗口中显示，就需要依赖MyWidget 窗口， 设置 MyWidget为父亲</p><p>案例一 qt_opecv</p><h4 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h4><p><img src="/images/qt1.png" alt="qt1"></p><h4 id="pro文件"><a href="#pro文件" class="headerlink" title=".pro文件"></a>.pro文件</h4><pre><code class="c++">    #-------------------------------------------------## Project created by QtCreator 2021-03-23T21:10:27##-------------------------------------------------QT       += core gui  //项目使用的模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //在4版本以上的qt中使用widgets模块TARGET = qt_opencv2  //生成的exe文件名TEMPLATE = app  //项目使用的模板# The following define makes your compiler emit warnings if you use# any feature of Qt which has been marked as deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if you use deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0CONFIG += c++11SOURCES += \             //源文件        main.cpp \        mainwindow.cppHEADERS += \              //头文件        mainwindow.hFORMS += \            //ui文件        mainwindow.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += targetinclude(&quot;c:/opencv/opencv.pri&quot;)  //包含opencv库RESOURCES += \            //项目所使用的资源文件（图片，音频等）    resources.qrc</code></pre><h4 id="在-pr中包含的opencv-pri文件"><a href="#在-pr中包含的opencv-pri文件" class="headerlink" title="在.pr中包含的opencv.pri文件"></a>在.pr中包含的opencv.pri文件</h4><pre><code class="c++">INCLUDEPATH += c:\opencv\qt_build\install\includeCONFIG(debug, debug|release): &#123;LIBS += c:\opencv\qt_build\install\x64\mingw\bin\libopencv_*d.dll&#125; else:CONFIG(release, debug|release): &#123;LIBS += -Lc:\opencv\qt_build\install\x64\mingw\bin\    -llibopencv_core451 \    -llibopencv_highgui451 \    -llibopencv_imgcodecs451 \    -llibopencv_imgproc451 \    -llibopencv_features2d451 \    -llibopencv_calib3d451&#125;</code></pre><h4 id="mainwindow-h"><a href="#mainwindow-h" class="headerlink" title="mainwindow.h"></a>mainwindow.h</h4><p>​    这个头文件定义了mainwindow类，以及他的函数，也包含了mainwindow.cpp所需的头文件</p><pre><code class="c++">#ifndef MAINWINDOW_H  //与文件尾部#endif // MAINWINDOW_H 共同起到了防止重复包含#define MAINWINDOW_H#include&lt;QDir&gt;#include&lt;QFile&gt;#include &lt;QMainWindow&gt;#include &lt;QFileDialog&gt;#include&lt;opencv2/opencv.hpp&gt;#include &lt;QMessageBox&gt;#include &lt;QCloseEvent&gt;#include &lt;QSettings&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123;    Q_OBJECT  //qt文件的基类public:    explicit MainWindow(QWidget *parent = nullptr);    ~MainWindow();private slots:    void on_inputPushButton_pressed(); //qt中的槽函数，    void on_outputPushButton_pressed();private:    Ui::MainWindow *ui;    void loadSettings();     //加载设置    void saveSettings();    //保存设置protected:    void closeEvent(QCloseEvent *event); //确认关闭窗口退出程序&#125;;#endif // MAINWINDOW_H</code></pre><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><p>​    main函数，程序的入口</p><pre><code class="c++">#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt; //负责控制应用程序的控制流、设置等的主要类int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);  //创建了QApplication类的一个实例，并将应用程序的参数（通常通过命令行或者终端传递）传递给    //名为a的实例    MainWindow w; //mainwindow类的实例w    w.show();//调用show（）显示该实例    return a.exec();//调用QApplication类的exec()函数，以便应用程序进入主循环，并一直保持到窗口关闭为止&#125;</code></pre><h4 id="mainwindow-cpp"><a href="#mainwindow-cpp" class="headerlink" title="mainwindow.cpp"></a>mainwindow.cpp</h4><p>​        包含mainwindow类各种方法的实现，信号槽函数的实现</p><pre><code></code></pre><pre><code class="c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;  //qt的uic编译的ui文件的头文件#include&lt;opencv2/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;MainWindow::MainWindow(QWidget *parent) : //mainwindow的构造函数实现,参数列表    QMainWindow(parent),    //以Qmainwindow类为父容器    ui(new Ui::MainWindow)   //&#123;    ui-&gt;setupUi(this);    loadSettings();    //加载设置，具体实现在下方&#125;MainWindow::~MainWindow() //析构&#123;    delete ui;&#125;void MainWindow::on_inputPushButton_pressed()   //inputPushButton的槽函数具体实现&#123;    QString filename = QFileDialog::getOpenFileName(this,                                                    &quot;Open Input Image&quot;,                                                    QDir::currentPath(),                                                    &quot;Images (*.jpg *.png *.bmp *.tiff)&quot;);    if(QFile::exists(filename))    &#123;        ui-&gt;inputLineEdit-&gt;setText(filename);    &#125;&#125;void MainWindow::on_outputPushButton_pressed()&#123;    QString fileName = QFileDialog::getSaveFileName(this,                                                    &quot;Select Output Image&quot;,                                                    QDir::currentPath(),                                                    &quot;*.JPG ;;*.PNG;;*.BMP;;*.TIFF&quot;);    if(!fileName.isEmpty())&#123;        ui-&gt;outputLineEdit-&gt;setText(fileName);        using namespace  cv;        Mat inpImg, outImg;        inpImg = imread(ui-&gt;inputLineEdit-&gt;text().toStdString());        if(ui-&gt;medianBlurRadioButton-&gt;isChecked())            cv::medianBlur(inpImg,outImg,5);        else if (ui-&gt;gaussianBlurRadioButton-&gt;isChecked())            cv::GaussianBlur(inpImg,outImg,Size(5,5),1.25);        imwrite(fileName.toStdString(),outImg);        if(ui-&gt;displayImageCheckBox-&gt;isChecked())            imshow(&quot;Output image&quot;,outImg);    &#125;&#125;void MainWindow::loadSettings()&#123;    QSettings settings(&quot;Packt&quot;,                      &quot;qt_opencv2&quot;,                      this);    ui-&gt;inputLineEdit-&gt;setText(settings.value(&quot;inputLineEdit&quot;,&quot;&quot;).toString());    ui-&gt;outputLineEdit-&gt;setText(settings.value(&quot;outputLineEdit&quot;,&quot;&quot;).toString());    ui-&gt;medianBlurRadioButton-&gt;setChecked(settings.value(&quot;medianBlurRadioButton&quot;,true).toBool());    ui-&gt;gaussianBlurRadioButton-&gt;setChecked(settings.value(&quot;gaussianBlurRadioButtin&quot;,false).toBool());    ui-&gt;displayImageCheckBox-&gt;setChecked(settings.value(&quot;displayImageCheckBox&quot;,false).toBool());&#125;void MainWindow::saveSettings()&#123;    QSettings settings(&quot;Packt&quot;,                      &quot;qt_opencv2&quot;,                       this);    settings.setValue(&quot;inputLIneEdit&quot;,ui-&gt;inputLineEdit-&gt;text());    settings.setValue(&quot;outputLineEdit&quot;,ui-&gt;outputLineEdit-&gt;text());    settings.setValue(&quot;medianBlurRadioButton&quot;,ui-&gt;medianBlurRadioButton-&gt;isChecked());    settings.setValue(&quot;gaussianBlurRadioButton&quot;,ui-&gt;gaussianBlurRadioButton-&gt;isChecked());    settings.setValue(&quot;displayImageCheckBox&quot;,ui-&gt;displayImageCheckBox-&gt;isChecked());&#125;void MainWindow::closeEvent(QCloseEvent *event)&#123;    int result = QMessageBox::warning(this,                                      &quot;Exit&quot;,                                      &quot;Are you sure you want to close this program?&quot;,                                      QMessageBox::Yes,                                      QMessageBox::No);    if(result == QMessageBox::Yes)    &#123;        saveSettings();        event-&gt;accept();    &#125;    else &#123;        &#123;            event-&gt;ignore();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">关于qt的零散学习笔记</summary>
    
    
    
    <category term="qt" scheme="https://zqy000.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="https://zqy000.github.io/tags/qt/"/>
    
    <category term="学习笔记" scheme="https://zqy000.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="opencv" scheme="https://zqy000.github.io/tags/opencv/"/>
    
    <category term="gui" scheme="https://zqy000.github.io/tags/gui/"/>
    
  </entry>
  
  <entry>
    <title>Bilibili视频下载器</title>
    <link href="https://zqy000.github.io/2019/09/21/Bilibili%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <id>https://zqy000.github.io/2019/09/21/Bilibili%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%99%A8/</id>
    <published>2019-09-21T09:53:56.000Z</published>
    <updated>2021-03-27T15:28:04.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bilibil视频下载器"><a href="#bilibil视频下载器" class="headerlink" title="bilibil视频下载器"></a>bilibil视频下载器</h2><p>​    主要是想下载自己收藏夹。使用python编写的代码，简单易懂。登录的信息以及登录全过程仅涉及自己的主机以及B站，代码开源，github地址为<a href="https://zqy000.github.io/">bilibili视频下载器</a>。</p>]]></content>
    
    
    <summary type="html">一个可以下载自己收藏列表的bilibili视频下载器，可以下载自己收藏的一系列课程视频。</summary>
    
    
    
    <category term="python" scheme="https://zqy000.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://zqy000.github.io/tags/python/"/>
    
    <category term="qt" scheme="https://zqy000.github.io/tags/qt/"/>
    
    <category term="bilibili" scheme="https://zqy000.github.io/tags/bilibili/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记（一）</title>
    <link href="https://zqy000.github.io/2019/07/27/c-learning/"/>
    <id>https://zqy000.github.io/2019/07/27/c-learning/</id>
    <published>2019-07-27T15:24:52.000Z</published>
    <updated>2021-03-27T15:31:10.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c语言学习笔记-一"><a href="#c语言学习笔记-一" class="headerlink" title="c语言学习笔记(一)"></a>c语言学习笔记(一)</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h5><p>我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p><pre><code class="c++">class Box&#123;   public:      double length;   // 盒子的长度      double breadth;  // 盒子的宽度      double height;   // 盒子的高度&#125;;</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png" alt="类定义"></p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><pre><code class="C++">C::C( double a, double b, double c): X(a), Y(b), Z(c) &#123;  .... &#125;</code></pre><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>  拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p><ul><li><p>通过使用另一个同类型的对象来初始化新创建的对象。</p></li><li><p>复制对象把它作为参数传递给函数。</p></li><li><p>复制对象，并从函数返回这个对象。</p></li><li><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p><pre><code class="c++">Line::Line(const Line &amp;obj)&#123;    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;    ptr = new int;    *ptr = *obj.ptr; // 拷贝值&#125; Line::~Line(void)&#123;    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;    delete ptr;&#125;</code></pre></li></ul><h4 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h4><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li><p>基于进程的多任务处理是程序的并发执行。</p></li><li><p>基于线程的多任务处理是同一程序的片段的并发执行</p><h6 id="c-11-新类-thread"><a href="#c-11-新类-thread" class="headerlink" title="c++11 新类 thread"></a>c++11 新类 thread</h6><p>detch()启动线程： detch()方法的意思就是开启子线程，并且主线程不等待子线程运行完毕，而是和子线程并行运行。</p></li></ul><p>join()方法启动线程：join()方法的意思就是开启子线程，线程会按照开启的先后顺序同步运行。</p><pre><code class="c++">#include &lt;thread&gt;#include &lt;Windows.h&gt;using namespace std;void TestThread1();void TestThread2();int main()&#123;  thread t1(TestThread1);        t1.detach();  //t1.join();    thread t2(TestThread2);    t2.detach();  //t2.join();    printf(&quot;主线程：你好帅！！！！\n&quot;);  system(&quot;pause&quot;);&#125;void TestThread1()&#123;    for (int i = 0; i &lt; 10; i++)&#123;        printf(&quot;TestThread1:%d\n&quot;, i);        Sleep(100);    &#125;&#125;void TestThread2()&#123;    for (int i = 100; i &lt; 110; i++)&#123;        printf(&quot;TestThread2:%d\n&quot;, i);        Sleep(100);    &#125;&#125;</code></pre><p>  <strong>子线程函数带有参数的多线程：</strong></p><pre><code class="c++">#include &lt;thread&gt;#include &lt;Windows.h&gt;using namespace std;void TestThread1(int count);void TestThread2(int start ,int count);int main()&#123;    thread t1(TestThread1,10);    t1.detach();    thread t2(TestThread2,40,50);    t2.detach();    printf(&quot;主线程：你好帅！！！！\n&quot;);    system(&quot;pause&quot;);&#125;void TestThread1(int count)&#123;    for (int i = 0; i &lt; count; i++)&#123;        printf(&quot;TestThread1:%d\n&quot;, i);        Sleep(100);    &#125;&#125;void TestThread2(int start,int count)&#123;    for (int i = start; i &lt; count; i++)&#123;        printf(&quot;TestThread2:%d\n&quot;, i);        Sleep(100);    &#125;&#125;</code></pre><p>多线程安全访问共享数据例子（卖票）<br>ThreadTest.h头文件</p><pre><code class="c++">#ifndef _THREAD_TEST_H_#define _THREAD_TEST_H_#include &lt;stdio.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;Windows.h&gt;using namespace std;class ThreadTest&#123;public:    //卖票线程1    void hread1();    //卖票线程2    void hread2();    ThreadTest();    ~ThreadTest();private:    //票的剩余数目    int Sum;    mutex Mutex;//线程锁&#125;;#endif // !_THREAD_TEST_H_</code></pre><p>ThreadTest.cpp 文件</p><pre><code class="c++">#include &quot;test.h&quot;using namespace std;void ThreadTest::hread1() &#123;    for (;;) &#123;        Mutex.lock();//加锁        Sleep(10);        --Sum;        if (Sum &lt; 0) &#123;            printf(&quot;Thrad1——票卖完了\n&quot;, Sum);            break;        &#125;        printf(&quot;Thrad1——剩余票数：%d\n&quot;, Sum);        Mutex.unlock();//解锁    &#125;    Mutex.unlock();//解锁&#125;void  ThreadTest::hread2() &#123;    for (;;) &#123;        Mutex.lock();//加锁               Sleep(10);        --Sum;        if (Sum &lt; 0) &#123;            printf(&quot;Thrad2——票卖完了\n&quot;);            break;        &#125;        printf(&quot;Thrad2——剩余票数：%d\n&quot;, Sum);        Mutex.unlock();//解锁    &#125;    Mutex.unlock();//解锁&#125;//构造函数ThreadTest::ThreadTest()&#123;    Sum = 50;    thread t1(&amp;ThreadTest::hread1, this);    t1.detach();    thread t2(&amp;ThreadTest::hread2, this);    t2.detach();&#125;//析构函数ThreadTest::~ThreadTest()&#123;&#125;</code></pre><p>main</p><pre><code class="c++">#include &quot;test.h&quot;int main() &#123;    //多线程卖票类    ThreadTest SaleThread;    while (true) &#123;        //为了截图方便--加入死循环    &#125;&#125;</code></pre><h1 id="include-pthread库"><a href="#include-pthread库" class="headerlink" title="include //pthread库"></a>include<pthread> //pthread库</h1><pre><code class="c++">#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) </code></pre><table><thead><tr><th>thread</th><th align="left">指向线程标识符指针。</th></tr></thead><tbody><tr><td>attr</td><td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td></tr><tr><td>start_routine</td><td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td></tr><tr><td>arg</td><td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td></tr></tbody></table><p>  创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>  使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><pre><code class="c++">#include &lt;pthread.h&gt;pthread_exit (status) </code></pre><p>  如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p><pre><code class="c++">#include &lt;iostream&gt;// 必须的头文件#include &lt;pthread.h&gt; using namespace std; #define NUM_THREADS 5 // 线程的运行函数void* say_hello(void* args)&#123;    cout &lt;&lt; &quot;Hello Runoob！&quot; &lt;&lt; endl;    return 0;&#125; int main()&#123;    // 定义线程的 id 变量，多个变量使用数组    pthread_t tids[NUM_THREADS];    for(int i = 0; i &lt; NUM_THREADS; ++i)    &#123;        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数        int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL);        if (ret != 0)        &#123;           cout &lt;&lt; &quot;pthread_create error: error_code=&quot; &lt;&lt; ret &lt;&lt; endl;        &#125;    &#125;    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；    pthread_exit(NULL);&#125;</code></pre><h5 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h5>]]></content>
    
    
    <summary type="html">关于C++的零散学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://zqy000.github.io/categories/C/"/>
    
    
    <category term="-c++ -C++STL -学习笔记" scheme="https://zqy000.github.io/tags/c-C-STL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++ STL(一)</title>
    <link href="https://zqy000.github.io/2019/06/27/c-STL/"/>
    <id>https://zqy000.github.io/2019/06/27/c-STL/</id>
    <published>2019-06-27T15:24:28.000Z</published>
    <updated>2021-03-30T04:02:17.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h3><p>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       Vector：</p><p>可以高性能随机访问(使用下标或者at时间复杂度O(1),)，但不适合大量随机插入将或修改元素。</p><p>元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；</p><p>v[10]不进行合理性检测有越界风险，v.at（10）进行合理性检测，安全，建议使用at（）。<br>       Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template.0</p><p>0.</p><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p><h3 id="STL三大组件"><a href="#STL三大组件" class="headerlink" title="STL三大组件"></a>STL三大组件</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>​    常用的数据结构：数组(array),链表(list),tree(树)，栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性，这些数据分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种。</p><p>​     序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p><p>​    关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>  以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms).STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p><p>迭代器的种类:</p><table><thead><tr><th>输入迭代器</th><th>提供对数据的只读访问</th><th>只读，支持++、==、！=</th></tr></thead><tbody><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;//STL 中的容器 算法 迭代器void test01()&#123;    vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组    v.push_back(1); //vector 容器提供的插入数据的方法    v.push_back(5);    v.push_back(3);    v.push_back(7);    //迭代器    vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器    vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;    //算法 count 算法 用于统计元素的个数    int n = count(pStart, pEnd, 5);    cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;&#125;//STL 容器不单单可以存储基础数据类型，也可以存储类对象class Teacher&#123;public:    Teacher(int age) :age(age)&#123;&#125;;    ~Teacher()&#123;&#125;;public:    int age;&#125;;void test02()&#123;    vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器    Teacher t1(10), t2(20), t3(30);    v.push_back(t1);    v.push_back(t2);    v.push_back(t3);    vector&lt;Teacher&gt;::iterator pStart = v.begin();    vector&lt;Teacher&gt;::iterator pEnd = v.end();    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;&#125;//存储 Teacher 类型指针void test03()&#123;    vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针    Teacher* t1 = new Teacher(10);    Teacher* t2 = new Teacher(20);    Teacher* t3 = new Teacher(30);    v.push_back(t1);    v.push_back(t2);    v.push_back(t3);    //拿到容器迭代器    vector&lt;Teacher*&gt;::iterator pStart = v.begin();    vector&lt;Teacher*&gt;::iterator pEnd = v.end();    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;&#125;//容器嵌套容器 难点(不理解，可以跳过)void test04()&#123;    vector&lt; vector&lt;int&gt; &gt; v;    vector&lt;int&gt;v1;    vector&lt;int&gt;v2;    vector&lt;int&gt;v3;    for (int i = 0; i &lt; 5;i++)    &#123;        v1.push_back(i);        v2.push_back(i * 10);        v3.push_back(i * 100);    &#125;    v.push_back(v1);    v.push_back(v2);    v.push_back(v3);    for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)    &#123;        for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)        &#123;            cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125; int main()&#123;    //test01();    //test02();    //test03();    test04();    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h4 id="string容器："><a href="#string容器：" class="headerlink" title="string容器："></a>string容器：</h4><p>  #include<string></p><h5 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h5><p>C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。</p><p>String和c风格字符串对比：</p><p>Char*是一个指针，String是一个类</p><p>string封装了char*，管理这个字符串，是一个char*型的容器。</p><p>不用考虑内存释放和越界</p><p> string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p><h6 id="String封装了很多实用的成员方法"><a href="#String封装了很多实用的成员方法" class="headerlink" title="String封装了很多实用的成员方法:"></a>String封装了很多实用的成员方法:</h6><pre><code>查找find：拷贝copy：删除delete：替换replace：插入Insert：</code></pre><h5 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h5><pre><code class="c++">string();//创建一个空的字符串 例如: string str;      string(const string&amp; str);//使用一个string对象初始化另一个string对象string(const char* s);//使用字符串s初始化string(int n, char c);//使用n个字符c初始化 </code></pre><h5 id="string基本赋值操作"><a href="#string基本赋值操作" class="headerlink" title="string基本赋值操作"></a>string基本赋值操作</h5><pre><code class="c++">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串string&amp; operator=(char c);//字符赋值给当前的字符串string&amp; assign(const char *s);//把字符串s赋给当前的字符串string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串string&amp; assign(int n, char c);//用n个字符c赋给当前字符串string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</code></pre><h5 id="string存取字符操作"><a href="#string存取字符操作" class="headerlink" title="string存取字符操作"></a>string存取字符操作</h5><pre><code class="c++">char&amp; operator[](int n);//通过[]方式取字符char&amp; at(int n);//通过at方法获取字符</code></pre><h5 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h5><pre><code class="c++">string&amp; operator+=(const string&amp; str);//重载+=操作符string&amp; operator+=(const char* str);//重载+=操作符string&amp; operator+=(const char c);//重载+=操作符string&amp; append(const char *s);//把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s);//同operator+=()string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</code></pre><h5 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h5><pre><code class="c++">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</code></pre><h5 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h5><pre><code class="c++">/*compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。*/int compare(const string &amp;s) const;//与字符串s比较int compare(const char *s) const;//与字符串s比较</code></pre><h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><pre><code class="c++">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</code></pre><h5 id="string插入和删除操作"><a href="#string插入和删除操作" class="headerlink" title="string插入和删除操作"></a>string插入和删除操作</h5><pre><code class="c++">string&amp; insert(int pos, const char* s); //插入字符串string&amp; insert(int pos, const string&amp; str); //插入字符串string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 </code></pre><h5 id="string和c-style字符串转换"><a href="#string和c-style字符串转换" class="headerlink" title="string和c-style字符串转换"></a>string和c-style字符串转换</h5><pre><code class="c++">//string 转 char*string str = &quot;itcast&quot;;const char* cstr = str.c_str();//char* 转 string char* s = &quot;itcast&quot;;string str(s);</code></pre><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><h5 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h5><p><img src="/images/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p><h5 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h5><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator-&gt;, operator++, operator–, operator+, operator-, operator+=, operator-=, 普通指针天生具备。Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators).</p><p>根据上述描述，如果我们写如下的代码：</p><p>Vector<int>::iterator it1;</p><p>Vector<Teacher>::iterator it2;</p><p>it1的型别其实就是Int*,it2的型别其实就是Teacher*.</p><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 10;i ++)&#123;        v.push_back(i);        cout &lt;&lt; v.capacity() &lt;&lt; endl;  // v.capacity()容器的容量    &#125;    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h4 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h4><p>Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><p>注意&gt; 所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p><h4 id="vector常用API操作"><a href="#vector常用API操作" class="headerlink" title="vector常用API操作"></a>vector常用API操作</h4><h5 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h5><pre><code class="c++">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。vector(n, elem);//构造函数将n个elem拷贝给本身。vector(const vector &amp;vec);//拷贝构造函数。//例子 使用第二个构造函数 我们可以...int arr[] = &#123;2,3,4,1,9&#125;;vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); </code></pre><h5 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h5><pre><code class="c++">size();//返回容器中元素的个数empty();//判断容器是否为空resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。capacity();//容器的容量reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</code></pre><h5 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h5><pre><code class="c++">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。operator[];//返回索引idx所指的数据，越界时，运行直接报错front();//返回容器中第一个数据元素back();//返回容器中最后一个数据元素</code></pre><h5 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h5><pre><code class="c++">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.push_back(ele); //尾部插入元素elepop_back();//删除最后一个元素erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素erase(const_iterator pos);//删除迭代器指向的元素clear();//删除容器中所有元素//c++中vector的排序函数：sort()    int s[] = &#123;1,6,3,2,5&#125;;    vector&lt;int&gt; vec(s, s+5);    //正向排序：按照从小到大的顺序排序    sort(vec.begin(), vec.end());    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    //逆向排序：按照从大到小的顺序进行排序    sort(vec.rbegin(), vec.rend());    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;</code></pre><h5 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h5><pre><code class="c++">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。vector&amp; operator=(const vector  &amp;vec);//重载等号操作符swap(vec);// 将vec与本身的元素互换。</code></pre><h5 id="vector小案例"><a href="#vector小案例" class="headerlink" title="vector小案例"></a>vector小案例</h5><h6 id="巧用swap，收缩内存空间"><a href="#巧用swap，收缩内存空间" class="headerlink" title="巧用swap，收缩内存空间"></a>巧用swap，收缩内存空间</h6><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 100000;i ++)&#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    //此时 通过resize改变容器大小    v.resize(10);cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    //容量没有改变    vector&lt;int&gt;(v).swap(v);    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h4><p>Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><p><img src="/images/clip_image002-1616936871298.jpg" alt="说明: 2015-11-19_204101"></p><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p><p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p><h4 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a>deque容器实现原理</h4><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p><p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><strong><img src="/images/clip_image002-1616937273304.jpg" alt="说明: 2015-11-19_204209"></strong></p><h4 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a>deque常用API</h4><h5 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h5><pre><code class="c++">deque&lt;T&gt; deqT;//默认构造形式deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem);//构造函数将n个elem拷贝给本身。deque(const deque &amp;deq);//拷贝构造函数。</code></pre><h5 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h5><pre><code class="c++">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换</code></pre><h5 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h5><pre><code class="c++">deque.size();//返回容器中元素的个数deque.empty();//判断容器是否为空deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</code></pre><h5 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h5><pre><code class="c++">push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据</code></pre><h5 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h5><pre><code class="c++">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。front();//返回第一个数据。back();//返回最后一个数据</code></pre><h5 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h5><pre><code class="c++">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</code></pre><h5 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h5><pre><code class="c+=">clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。</code></pre><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><pre><code class="c++">//</code></pre><h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h4><p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p>]]></content>
    
    
    <summary type="html">关于C++STL的零散学习笔记(一)</summary>
    
    
    
    <category term="C++" scheme="https://zqy000.github.io/categories/C/"/>
    
    
    <category term="学习笔记" scheme="https://zqy000.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="c++" scheme="https://zqy000.github.io/tags/c/"/>
    
    <category term="C++ STL" scheme="https://zqy000.github.io/tags/C-STL/"/>
    
    <category term="STL string" scheme="https://zqy000.github.io/tags/STL-string/"/>
    
  </entry>
  
</feed>
