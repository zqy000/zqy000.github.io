<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 学习笔记(1)</title>
      <link href="2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-学习笔记-1"><a href="#Java-学习笔记-1" class="headerlink" title="Java 学习笔记(1)"></a>Java 学习笔记(1)</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        Java最大的优点在于设计之初就秉承了“一次编写，到处运行（Write once,Run Everywhere).”Java语言编写的程序可以在编译后不经任何改动，就能在其他平台上运行，这得益于它的JVM（Java virtual Machine)的机制屏蔽了“翻译”的细节，由JVM负责翻译沟通。</p><p><img src="http://c.biancheng.net/uploads/allimg/190903/5-1ZZ3131223943.png" alt="JVM"></p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        JVM:Java编译器javac将源代码编译成.class文件，然后通过命令java将.class送往Java虚拟机(JVM)最终变成可执行程序。JVM可以看作是在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上提供给编译器一个共同的接口，编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，将这种供虚拟机理解的代码叫做字节码(Byte Code)，他不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机确实相同的。</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE(Java Runtime Environment):JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现以及JAVA核心类库。一个Java程序想要运行在Java虚拟机之中，源代码的语句需要由Java编译器编译成字节码。字节码本质上是一种标准化的可移植的二进制格式。改格式以Java类文件.class的形式存在。一个Java程序可以由多个不同的.class文件构成，通常将多个.class文件打包成一个发布文件.jar。其扩展名来自于”java archive”(java归档文件)的简写。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK(Java Development Kit):Java开发工具包，包括了JRE(Java Runtime Environment)、编译（javac）、解释（java）、打包（jre）等工具还包括开发工具以及开发工具的应用程序接口。</p><h2 id="JAVA基础概念"><a href="#JAVA基础概念" class="headerlink" title="JAVA基础概念"></a>JAVA基础概念</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p></li><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p></li><li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p></li><li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><pre><code class="java">public class HelloWorld &#123;    /* 第一个Java程序     * 它将输出字符串 Hello World     */    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;); // 输出 Hello World    &#125;&#125;</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg"></p></li></ul><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li></ul><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p><h4 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a><strong>Java修饰符</strong></h4><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h4 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a><strong>Java 标识符</strong></h4><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li></ul><h4 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a><strong>Java 变量</strong></h4><p>Java 中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a><strong>Java 数组</strong></h4><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p><h4 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a><strong>Java 枚举</strong></h4><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><h4 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a><strong>Java注释</strong></h4><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。空白行或者有注释的行，Java 编译器都会忽略掉。</p><pre><code class="java">public class HelloWorld &#123;   /* 这是第一个Java程序    * 它将输出 Hello World    * 这是一个多行注释的示例    */    public static void main(String[] args)&#123;       // 这是单行注释的示例       /* 这个也是单行注释的示例 */       System.out.println(&quot;Hello World&quot;);     &#125;&#125;</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h4 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h4><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png"></p><h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><p>Java作为一种面向对象语言。支持以下基本概念：</p><p>​    多态、继承、封装、抽象、类、对象、实例、方法、重载。</p><ul><li><p><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p></li><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p></li></ul><p>汽车为类（class），而具体的每辆车为该<strong>汽车</strong>类的<strong>对象（object）</strong>，对象包含了汽车的颜色、品牌、名称等。</p><p>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/20210105-java-object-1.png"></p><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。static被引入以告知<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>，将变量存储在程序的静态存储区而非栈上空间。static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的存取范围不变。</li></ul><p>类中的static成员：</p><p>一、出现原因及作用：</p><p>1、需要在一个类的各个对象间交互，即需要一个<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">数据对象</a>为整个类而非某个对象服务。</p><p>2、同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。</p><p>类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。</p><p>对于静态的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，注意<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a>嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p>类的静态成员函数是属于整个类而非类的对象，所以它没有this<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，这就导致了它仅能访问类的静态数据和静态成员函数。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法（多态：有参构造、无参构造）。</p><p>下面是一个构造方法示例：</p><pre><code class="java">public class Puppy&#123;    public Puppy()&#123;    &#125;     public Puppy(String name)&#123;        // 这个构造器仅有一个参数：name    &#125;&#125;</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><p>下面是一个创建对象的例子：</p><pre><code class="java">public class Puppy&#123;   public Puppy(String name)&#123;      //这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;   public static void main(String[] args)&#123;      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( &quot;tommy&quot; );   &#125;&#125;</code></pre><h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><pre><code class="java">public class Puppy&#123;   int puppyAge;   public Puppy(String name)&#123;      // 这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;    public void setAge( int age )&#123;       puppyAge = age;   &#125;    public int getAge( )&#123;       System.out.println(&quot;小狗的年龄为 : &quot; + puppyAge );        return puppyAge;   &#125;    public static void main(String[] args)&#123;      /* 创建对象 */      Puppy myPuppy = new Puppy( &quot;tommy&quot; );      /* 通过方法来设定age */      myPuppy.setAge( 2 );      /* 调用另一个方法获取age */      myPuppy.getAge( );      /*你也可以像下面这样访问成员变量 */      System.out.println(&quot;变量值 : &quot; + myPuppy.puppyAge );    &#125;&#125;</code></pre><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><p>类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。</p><p>除了上面提到的几种类型，Java 还有一些特殊的类，如：<a href="https://www.runoob.com/java/java-inner-class.html">内部类</a>、<a href="https://www.runoob.com/java/java-anonymous-class.html">匿名类</a>。</p><h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java 的两大数据类型:</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p>byte：8位、有符号</p><p>short：16位、有符号</p><p>int：32位、有符号、一般地整型变量默认为 int 类型</p><p>long：64位、有符号、</p><p>float：32位、单精度、浮点数</p><p>double：64位、双精度</p><p>boolean：1位、取值true或false</p><p>char：16位Unicode字符</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>​    在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p><ul><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li><li>通常使用大写字母表示常量。</li></ul><h4 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h4><p>常量在程序运行时是不能被修改的。</p><p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p><pre><code class="java">final double PI = 3.1415927;</code></pre><p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p><p>当使用字面量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：</p><pre><code class="java">int decimal = 100;int octal = 0144;int hexa =  0x64;</code></pre><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级。</p><pre><code class="java">低  ------------------------------------&gt;  高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </code></pre><p>数据类型转换必须满足如下规则：</p><ul><li>\1. 不能对boolean类型进行类型转换。</li><li>\2. 不能把对象类型转换成不相关类的对象。</li><li>\3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>\4. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li><li>\5. 转换过程中可能导致溢出或损失精度，例如：</li></ul><pre><code class="java">int i =128;   byte b = (byte)i;</code></pre><h2 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h2><p>Java语言支持的变量类型有：</p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><h4 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h4><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><h4 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h4><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p><pre><code class="java">public class ClassName &#123;   // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123;   // 方法体&#125;</code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><p>static 修饰符，用来修饰类方法和类变量。</p><p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p><h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h4><ul><li><p><strong>静态变量：</strong></p><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p><strong>静态方法：</strong></p><p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p><p>如下例所示，static修饰符用来创建类方法和类变量。</p></li></ul><pre><code class="java">public class InstanceCounter &#123;   private static int numInstances = 0;   protected static int getCount() &#123;      return numInstances;   &#125;    private static void addInstance() &#123;      numInstances++;   &#125;    InstanceCounter() &#123;      InstanceCounter.addInstance();   &#125;    public static void main(String[] arguments) &#123;      System.out.println(&quot;Starting with &quot; +      InstanceCounter.getCount() + &quot; instances&quot;);      for (int i = 0; i &lt; 500; ++i)&#123;         new InstanceCounter();          &#125;      System.out.println(&quot;Created &quot; +      InstanceCounter.getCount() + &quot; instances&quot;);   &#125;&#125;</code></pre><h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><p><strong>final 变量：</strong></p><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><p><strong>final 方法</strong></p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p><p>声明 final 方法的主要目的是防止该方法的内容被修改。</p><p>如下所示，使用 final 修饰符声明方法。</p><pre><code class="java">public class Test&#123;    public final void changeName()&#123;       // 方法体    &#125;&#125;</code></pre><p><strong>final 类</strong></p><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h4><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p><pre><code class="java">abstract class Caravan&#123;   private double price;   private String model;   private String year;   public abstract void goFast(); //抽象方法   public abstract void changeColor();&#125;</code></pre><p><strong>抽象方法</strong></p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾，例如：**public abstract sample();**。</p><h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p><h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。用<strong>transient</strong>声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p><p><strong>序列化</strong>：把Java对象转换为字节序列的过程。<br><strong>反序列化</strong>：把字节序列恢复为Java对象的过程。</p><p>用途：</p><ul><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；（<strong>持久化对象</strong>）</li><li>在网络上传送对象的字节序列。（<strong>网络传输对象</strong>）</li></ul><h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h4><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p><pre><code class="java">public class MyRunnable implements Runnable&#123;    private volatile boolean active;    public void run()    &#123;        active = true;        while (active) // 第一行        &#123;            // 代码        &#125;    &#125;    public void stop()    &#123;        active = false; // 第二行    &#125;&#125;</code></pre><p>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 *<strong>第一行*</strong> 中缓冲区的 active 值被使用，那么在 *<strong>第二行*</strong> 的 active 值为 false 时循环不会停止。</p><p>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。</p><h2 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h2><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p><p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法 - 相加运算符两侧的值</td><td align="left">A + B 等于 30</td></tr><tr><td align="left">-</td><td align="left">减法 - 左操作数减去右操作数</td><td align="left">A – B 等于 -10</td></tr><tr><td align="left">*</td><td align="left">乘法 - 相乘操作符两侧的值</td><td align="left">A * B等于200</td></tr><tr><td align="left">/</td><td align="left">除法 - 左操作数除以右操作数</td><td align="left">B / A等于2</td></tr><tr><td align="left">％</td><td align="left">取余 - 左操作数除以右操作数的余数</td><td align="left">B%A等于0</td></tr><tr><td align="left">++</td><td align="left">自增: 操作数的值增加1</td><td align="left">B++ 或 ++B 等于 21（区别详见下文）</td></tr><tr><td align="left">–</td><td align="left">自减: 操作数的值减少1</td><td align="left">B– 或 –B 等于 19（区别详见下文）</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>下表为Java支持的关系运算符</p><p>表格中的实例整数变量A的值为10，变量B的值为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">（A == B）为假。</td></tr><tr><td align="left">!=</td><td align="left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td align="left">(A != B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; B）为假。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;B）为真。</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; = B）为假。</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;= B）为真。</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算。下表列出了位运算符的基本运算,假设整数变量 A 的值为 60 和变量 B 的值为 13：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A＆B），得到12，即0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td><td align="left">（A | B）得到61，即 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td align="left">（A &amp;&amp; B）为假。</td></tr><tr><td align="left">| |</td><td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td align="left">（A | | B）为真。</td></tr><tr><td align="left">！</td><td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td align="left">！（A &amp;&amp; B）为真。</td></tr></tbody></table><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><pre><code class="java">public class LuoJi&#123;    public static void main(String[] args)&#123;        int a = 5;//定义一个变量；        boolean b = (a&lt;4)&amp;&amp;(a++&lt;10);        System.out.println(&quot;使用短路逻辑运算符的结果为&quot;+b);        System.out.println(&quot;a的结果为&quot;+a);    &#125;//使用短路逻辑运算符的结果为false//a的结果为5&#125;</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下面是Java语言支持的赋值运算符：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td align="left">C = A + B将把A + B得到的值赋给C</td></tr><tr><td align="left">+ =</td><td align="left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td align="left">C + = A等价于C = C + A</td></tr><tr><td align="left">- =</td><td align="left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td align="left">C - = A等价于C = C - A</td></tr><tr><td align="left">* =</td><td align="left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td align="left">C * = A等价于C = C * A</td></tr><tr><td align="left">/ =</td><td align="left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td align="left">C / = A，C 与 A 同类型时等价于 C = C / A</td></tr><tr><td align="left">（％）=</td><td align="left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td align="left">C％= A等价于C = C％A</td></tr><tr><td align="left">&lt;&lt; =</td><td align="left">左移位赋值运算符</td><td align="left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt; =</td><td align="left">右移位赋值运算符</td><td align="left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td align="left">＆=</td><td align="left">按位与赋值运算符</td><td align="left">C＆= 2等价于C = C＆2</td></tr><tr><td align="left">^ =</td><td align="left">按位异或赋值操作符</td><td align="left">C ^ = 2等价于C = C ^ 2</td></tr><tr><td align="left">| =</td><td align="left">按位或赋值操作符</td><td align="left">C | = 2等价于C = C | 2</td></tr></tbody></table><h3 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h3><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><pre><code class="java">variable x = (expression) ? value if true : value if false</code></pre><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>instanceof运算符使用格式如下：</p><pre><code class="java">( Object reference variable ) instanceof  (class/interface type)</code></pre><p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><p>下面是一个例子：</p><pre><code class="javaa">String name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</code></pre><h3 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h3><p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p><table><thead><tr><th align="left">类别</th><th align="left">操作符</th><th align="left">关联性</th></tr></thead><tbody><tr><td align="left">后缀</td><td align="left">() [] . (点操作符)</td><td align="left">左到右</td></tr><tr><td align="left">一元</td><td align="left">expr++ expr–</td><td align="left">从左到右</td></tr><tr><td align="left">一元</td><td align="left">++expr –expr + - ～ ！</td><td align="left">从右到左</td></tr><tr><td align="left">乘性</td><td align="left">* /％</td><td align="left">左到右</td></tr><tr><td align="left">加性</td><td align="left">+ -</td><td align="left">左到右</td></tr><tr><td align="left">移位</td><td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td align="left">左到右</td></tr><tr><td align="left">关系</td><td align="left">&gt; &gt;= &lt; &lt;=</td><td align="left">左到右</td></tr><tr><td align="left">相等</td><td align="left">== !=</td><td align="left">左到右</td></tr><tr><td align="left">按位与</td><td align="left">＆</td><td align="left">左到右</td></tr><tr><td align="left">按位异或</td><td align="left">^</td><td align="left">左到右</td></tr><tr><td align="left">按位或</td><td align="left">|</td><td align="left">左到右</td></tr><tr><td align="left">逻辑与</td><td align="left">&amp;&amp;</td><td align="left">左到右</td></tr><tr><td align="left">逻辑或</td><td align="left">| |</td><td align="left">左到右</td></tr><tr><td align="left">条件</td><td align="left">？：</td><td align="left">从右到左</td></tr><tr><td align="left">赋值</td><td align="left">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td align="left">从右到左</td></tr><tr><td align="left">逗号</td><td align="left">，</td><td align="left">左到右</td></tr></tbody></table><h2 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h2><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。</p><p>Java中有三种主要的循环结构：</p><ul><li><strong>while</strong> 循环</li><li><strong>do…while</strong> 循环</li><li><strong>for</strong> 循环</li><li>在Java5中引入了一种主要用于数组的增强型for循环。</li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p><pre><code class="java">for(初始化; 布尔表达式; 更新) &#123;    //代码语句&#125;</code></pre><p>关于 for 循环有以下几点说明：</p><ul><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul><h3 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p><p>Java 增强 for 循环语法格式如下:</p><pre><code class="java">for(声明语句 : 表达式)&#123;   //代码句子&#125;//实例public class Test &#123;   public static void main(String args[])&#123;      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;       for(int x : numbers )&#123;         System.out.print( x );         System.out.print(&quot;,&quot;);      &#125;      System.out.print(&quot;\n&quot;);      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;      for( String name : names ) &#123;         System.out.print( name );         System.out.print(&quot;,&quot;);      &#125;   &#125;&#125;</code></pre><p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p><p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p><h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p><p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p><p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p><h2 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句- if…else"></a>Java 条件语句- if…else</h2><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p><p>if 语句的语法如下：</p><pre><code class="java">if(布尔表达式)&#123;   //如果布尔表达式为true将执行的语句&#125;//if...else if...else 语句if(布尔表达式 1)&#123;   //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123;   //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123;   //如果布尔表达式 3的值为true执行代码&#125;else &#123;   //如果以上布尔表达式都不为true执行代码&#125;//嵌套的 if…else 语句if(布尔表达式 1)&#123;   ////如果布尔表达式 1的值为true执行代码   if(布尔表达式 2)&#123;      ////如果布尔表达式 2的值为true执行代码   &#125;&#125;</code></pre><h2 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h2><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><p><strong>语法:</strong></p><p>switch case 语句语法格式如下：</p><pre><code class="java">switch(expression)&#123;    case value :       //语句       break; //可选    case value :       //语句       break; //可选    //你可以有任意数量的case语句    default : //可选       //语句&#125;</code></pre><p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p><p>switch case 语句有如下规则：</p><ul><li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li><li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（break，判断是否继续输出，或是跳出判断。**可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li></ul><h2 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h2><p>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：<strong>byte、int、long、double</strong> 等。然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。</p><p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p><table><thead><tr><th align="left">包装类</th><th align="left">基本数据类型</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">boolean</td></tr><tr><td align="left">Byte</td><td align="left">byte</td></tr><tr><td align="left">Short</td><td align="left">short</td></tr><tr><td align="left">Integer</td><td align="left">int</td></tr><tr><td align="left">Long</td><td align="left">long</td></tr><tr><td align="left">Character</td><td align="left">char</td></tr><tr><td align="left">Float</td><td align="left">float</td></tr><tr><td align="left">Double</td><td align="left">double</td></tr></tbody></table><p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p><h3 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h3><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><pre><code class="java">public class Test &#123;      public static void main (String []args)      &#123;          System.out.println(&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));          System.out.println(&quot;0度的余弦值：&quot; + Math.cos(0));          System.out.println(&quot;60度的正切值：&quot; + Math.tan(Math.PI/3));          System.out.println(&quot;1的反正切值： &quot; + Math.atan(1));          System.out.println(&quot;π/2的角度值：&quot; + Math.toDegrees(Math.PI/2));          System.out.println(Math.PI);      &#125;  &#125;</code></pre><h3 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h3><p>下面的表中列出的是 Number &amp; Math 类常用的一些方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/java/number-xxxvalue.html">xxxValue()</a> 将 Number 对象转换为xxx数据类型的值并返回。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/java/number-compareto.html">compareTo()</a> 将number对象与参数比较。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/java/number-equals.html">equals()</a> 判断number对象是否与参数相等。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/java/number-valueof.html">valueOf()</a> 返回一个 Number 对象指定的内置数据类型</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/java/number-tostring.html">toString()</a> 以字符串形式返回值。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/java/number-parseInt.html">parseInt()</a> 将字符串解析为int类型。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/java/number-abs.html">abs()</a> 返回参数的绝对值。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/java/number-ceil.html">ceil()</a> 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/java/number-floor.html">floor()</a> 返回小于等于（&lt;=）给定参数的最大整数 。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/java/number-rint.html">rint()</a> 返回与参数最接近的整数。返回类型为double。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/java/number-round.html">round()</a> 它表示<strong>四舍五入</strong>，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/java/number-min.html">min()</a> 返回两个参数中的最小值。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/java/number-max.html">max()</a> 返回两个参数中的最大值。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/java/number-exp.html">exp()</a> 返回自然数底数e的参数次方。</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/java/number-log.html">log()</a> 返回参数的自然数底数的对数值。</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/java/number-pow.html">pow()</a> 返回第一个参数的第二个参数次方。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/java/number-sqrt.html">sqrt()</a> 求参数的算术平方根。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/java/number-sin.html">sin()</a> 求指定double类型参数的正弦值。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/java/number-cos.html">cos()</a> 求指定double类型参数的余弦值。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/java/number-tan.html">tan()</a> 求指定double类型参数的正切值。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/java/number-asin.html">asin()</a> 求指定double类型参数的反正弦值。</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/java/number-acos.html">acos()</a> 求指定double类型参数的反余弦值。</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/java/number-atan.html">atan()</a> 求指定double类型参数的反正切值。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/java/number-atan2.html">atan2()</a> 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/java/number-todegrees.html">toDegrees()</a> 将参数转化为角度。</td></tr><tr><td align="left">26</td><td align="left"><a href="https://www.runoob.com/java/number-toradians.html">toRadians()</a> 将角度转换为弧度。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/java/number-random.html">random()</a> 返回一个随机数。</td></tr></tbody></table><h2 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h2><p>Character 类用于对单个字符进行操作。</p><p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值</p><pre><code class="java">char ch = &#39;a&#39;; // Unicode 字符表示形式char uniChar = &#39;\u039A&#39;;  // 字符数组char[] charArray =&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; &#125;;</code></pre><p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p><p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：</p><pre><code class="java">Character ch = new Character(&#39;a&#39;);</code></pre><p>在某些情况下，Java编译器会自动创建一个Character对象。</p><p>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p><pre><code class="java">// 原始字符 &#39;a&#39; 装箱到 Character 对象 ch 中Character ch = &#39;a&#39;; // 原始字符 &#39;x&#39; 用 test 方法装箱// 返回拆箱的值到 &#39;c&#39;char c = test(&#39;x&#39;);</code></pre><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table><thead><tr><th align="left">转义序列</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\t</td><td align="left">在文中该处插入一个tab键</td></tr><tr><td align="left">\b</td><td align="left">在文中该处插入一个后退键</td></tr><tr><td align="left">\n</td><td align="left">在文中该处换行</td></tr><tr><td align="left">\r</td><td align="left">在文中该处插入回车</td></tr><tr><td align="left">\f</td><td align="left">在文中该处插入换页符</td></tr><tr><td align="left">\‘</td><td align="left">在文中该处插入单引号</td></tr><tr><td align="left">\“</td><td align="left">在文中该处插入双引号</td></tr><tr><td align="left">\</td><td align="left">在文中该处插入反斜杠</td></tr></tbody></table><h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/java/character-isletter.html">isLetter()</a> 是否是一个字母</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a> 是否是一个数字字符</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a> 是否是一个空白字符</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a> 是否是大写字母</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a> 是否是小写字母</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a> 指定字母的大写形式</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>() 指定字母的小写形式</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/java/character-tostring.html">toString</a>() 返回字符的字符串形式，字符串的长度仅为1</td></tr></tbody></table><h2 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h2><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p><pre><code class="java">String str = &quot;Runoob&quot;;String str2=new String(&quot;Runoob&quot;);String s1 = &quot;Runoob&quot;;              // String 直接创建String s2 = &quot;Runoob&quot;;              // String 直接创建String s3 = s1;                    // 相同引用String s4 = new String(&quot;Runoob&quot;);   // String 对象创建String s5 = new String(&quot;Runoob&quot;);   // String 对象创建//String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提//供一个字符数组参数:char[] helloArray = &#123; &#39;r&#39;, &#39;u&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;b&#39;&#125;;String helloString = new String(helloArray);  </code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png"></p><h3 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a>String、StringBuffer 和 StringBuilder 的区别</h3><p><strong>String</strong>：字符串常量，字符串长度不可变。Java中String 是immutable（不可变）的。用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p><p><strong>StringBuffer</strong>：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。Java.lang.StringBuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</p><p><strong>StringBuilder</strong>：字符串变量（非线程安全）。在内部 StringBuilder 对象被当作是一个包含字符序列的变长数组。</p><p><strong>基本原则：</strong></p><ul><li>如果要操作少量的数据用 String ；</li><li>单线程操作大量数据用StringBuilder ；</li><li>多线程操作大量数据，用StringBuffer。</li><li>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了.如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</li></ul><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>用于获取有关对象的信息的方法称为访问器方法。</p><p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p><p>length() 方法，length 属性和 size() 方法的区别:</p><ul><li> 1、<strong>length()</strong> 方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</li><li> 2、<strong>length 属性</strong>是针对 Java 中的数组来说的，要求数组的长度可以用其 length 属性；</li><li> 3、Java 中的 <strong>size()</strong> 方法是针对泛型集合说的, 如果想看这个泛型有多少个元素, 就调用此方法来查看!</li></ul><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String 类提供了连接两个字符串的方法：</p><pre><code class="java">string1.concat(string2);//返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);//更常用的是使用&#39;+&#39;操作符来连接字符串，如：&quot;Hello,&quot; + &quot; runoob&quot; + &quot;!&quot;</code></pre><h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p><p>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。</p><p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p><pre><code class="java">System.out.printf(&quot;浮点型变量的值为 &quot; +                  &quot;%f, 整型变量的值为 &quot; +                  &quot; %d, 字符串变量的值为 &quot; +                  &quot;is %s&quot;, floatVar, intVar, stringVar);String fs;fs = String.format(&quot;浮点型变量的值为 &quot; +                   &quot;%f, 整型变量的值为 &quot; +                   &quot; %d, 字符串变量的值为 &quot; +                   &quot; %s&quot;, floatVar, intVar, stringVar);</code></pre><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><table><thead><tr><th align="left">SN(序号)</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td></tr><tr><td align="left">7</td><td align="left">[static String copyValueOf(char<a href="https://www.runoob.com/java/java-string-copyvalueof.html">] data)</a> 返回指定数组中表示该字符序列的 String。</td></tr><tr><td align="left">8</td><td align="left">[static String copyValueOf(char<a href="https://www.runoob.com/java/java-string-copyvalueof.html">] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td></tr><tr><td align="left">12</td><td align="left">[byte<a href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td align="left">13</td><td align="left">[byte<a href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td align="left">14</td><td align="left">[void getChars(int srcBegin, int srcEnd, char<a href="https://www.runoob.com/java/java-string-getchars.html">] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td></tr><tr><td align="left">26</td><td align="left"><a href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td></tr><tr><td align="left">29</td><td align="left"><a href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td align="left">32</td><td align="left">[String<a href="https://www.runoob.com/java/java-string-split.html">] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td></tr><tr><td align="left">33</td><td align="left">[String<a href="https://www.runoob.com/java/java-string-split.html">] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td></tr><tr><td align="left">34</td><td align="left"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td></tr><tr><td align="left">35</td><td align="left"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td></tr><tr><td align="left">36</td><td align="left"><a href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td></tr><tr><td align="left">37</td><td align="left"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td></tr><tr><td align="left">38</td><td align="left"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td></tr><tr><td align="left">39</td><td align="left">[char<a href="https://www.runoob.com/java/java-string-tochararray.html">] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td align="left">41</td><td align="left"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td align="left">42</td><td align="left"><a href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td></tr><tr><td align="left">43</td><td align="left"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td align="left">44</td><td align="left"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td align="left">45</td><td align="left"><a href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td></tr><tr><td align="left">46</td><td align="left"><a href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td></tr><tr><td align="left">47</td><td align="left"><a href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td></tr><tr><td align="left">48</td><td align="left"><a href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td></tr></tbody></table><h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-20201208.png"></p><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p><h3 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td></tr><tr><td align="left">2</td><td align="left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td></tr><tr><td align="left">3</td><td align="left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td></tr><tr><td align="left">4</td><td align="left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td></tr><tr><td align="left">5</td><td align="left">insert(int offset, String str) 将 <code>str</code> 参数的字符串插入此序列中。</td></tr><tr><td align="left">6</td><td align="left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">int capacity() 返回当前容量。</td></tr><tr><td align="left">2</td><td align="left">char charAt(int index) 返回此序列中指定索引处的 <code>char</code> 值。</td></tr><tr><td align="left">3</td><td align="left">void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。</td></tr><tr><td align="left">4</td><td align="left">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 <code>dst</code>。</td></tr><tr><td align="left">5</td><td align="left">int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。</td></tr><tr><td align="left">6</td><td align="left">int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td></tr><tr><td align="left">7</td><td align="left">int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。</td></tr><tr><td align="left">8</td><td align="left">int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。</td></tr><tr><td align="left">9</td><td align="left">int length()  返回长度（字符数）。</td></tr><tr><td align="left">10</td><td align="left">void setCharAt(int index, char ch) 将给定索引处的字符设置为 <code>ch</code>。</td></tr><tr><td align="left">11</td><td align="left">void setLength(int newLength) 设置字符序列的长度。</td></tr><tr><td align="left">12</td><td align="left">CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。</td></tr><tr><td align="left">13</td><td align="left">String substring(int start) 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td></tr><tr><td align="left">14</td><td align="left">String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td></tr><tr><td align="left">15</td><td align="left">String toString() 返回此序列中数据的字符串表示形式。</td></tr></tbody></table><h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><pre><code class="java">dataType[] arrayRefVar;   // 首选的方法 或 dataType arrayRefVar[];  // 效果相同，但不是首选方法//创建数组//Java语言使用new操作符来创建数组，语法如下：arrayRefVar = new dataType[arraySize];//使用 dataType[arraySize] 创建了一个数组。//把新创建的数组的引用赋值给变量 arrayRefVar。//数组变量的声明，和创建数组可以用一条语句完成dataType[] arrayRefVar = new dataType[arraySize];</code></pre><h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><pre><code class="java">1. 直接为每一维分配空间，格式如下：type[][] typeName = new type[typeLength1][typeLength2];2. 从最高维开始，分别为每一维分配空间，例如：String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(&quot;Good&quot;);s[0][1] = new String(&quot;Luck&quot;);s[1][0] = new String(&quot;to&quot;);s[1][1] = new String(&quot;you&quot;);s[1][2] = new String(&quot;!&quot;);</code></pre><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p><p>具有以下功能：</p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法和说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td></tr><tr><td align="left">2</td><td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="left">3</td><td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="left">4</td><td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr></tbody></table><h3 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h3><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p><pre><code class="java">//第一个构造函数使用当前日期和时间来初始化对象。Date( )//第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。Date(long millisec)</code></pre><p>Date对象创建以后，可以调用下面的方法。</p><table><thead><tr><th align="left">序号</th><th align="left">方法和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</td></tr><tr><td align="left">2</td><td align="left"><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td></tr><tr><td align="left">3</td><td align="left"><strong>Object clone( )</strong> 返回此对象的副本。</td></tr><tr><td align="left">4</td><td align="left"><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td></tr><tr><td align="left">5</td><td align="left"><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td></tr><tr><td align="left">6</td><td align="left"><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td></tr><tr><td align="left">7</td><td align="left"><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td></tr><tr><td align="left">8</td><td align="left"><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td></tr><tr><td align="left">9</td><td align="left"><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td></tr><tr><td align="left">10</td><td align="left"><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</td></tr></tbody></table><pre><code class="java">//获取当前日期时间import java.util.Date;  public class DateDemo &#123;   public static void main(String args[]) &#123;       // 初始化 Date 对象       Date date = new Date();               // 使用 toString() 函数显示日期时间       System.out.println(date.toString());   &#125;&#125;</code></pre><h3 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h3><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：</p><pre><code class="java">import  java.util.*;import java.text.*; public class DateDemo &#123;   public static void main(String args[]) &#123;       Date dNow = new Date( );      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);//当前时间为: 2018-09-06 10:16:34      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));   &#125;&#125;//注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。</code></pre><h4 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h4><p>时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：</p><table><thead><tr><th align="left"><strong>字母</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">G</td><td align="left">纪元标记</td><td align="left">AD</td></tr><tr><td align="left">y</td><td align="left">四位年份</td><td align="left">2001</td></tr><tr><td align="left">M</td><td align="left">月份</td><td align="left">July or 07</td></tr><tr><td align="left">d</td><td align="left">一个月的日期</td><td align="left">10</td></tr><tr><td align="left">h</td><td align="left">A.M./P.M. (1~12)格式小时</td><td align="left">12</td></tr><tr><td align="left">H</td><td align="left">一天中的小时 (0~23)</td><td align="left">22</td></tr><tr><td align="left">m</td><td align="left">分钟数</td><td align="left">30</td></tr><tr><td align="left">s</td><td align="left">秒数</td><td align="left">55</td></tr><tr><td align="left">S</td><td align="left">毫秒数</td><td align="left">234</td></tr><tr><td align="left">E</td><td align="left">星期几</td><td align="left">Tuesday</td></tr><tr><td align="left">D</td><td align="left">一年中的日子</td><td align="left">360</td></tr><tr><td align="left">F</td><td align="left">一个月中第几周的周几</td><td align="left">2 (second Wed. in July)</td></tr><tr><td align="left">w</td><td align="left">一年中第几周</td><td align="left">40</td></tr><tr><td align="left">W</td><td align="left">一个月中第几周</td><td align="left">1</td></tr><tr><td align="left">a</td><td align="left">A.M./P.M. 标记</td><td align="left">PM</td></tr><tr><td align="left">k</td><td align="left">一天中的小时(1~24)</td><td align="left">24</td></tr><tr><td align="left">K</td><td align="left">A.M./P.M. (0~11)格式小时</td><td align="left">10</td></tr><tr><td align="left">z</td><td align="left">时区</td><td align="left">Eastern Standard Time</td></tr><tr><td align="left">‘</td><td align="left">文字定界符</td><td align="left">Delimiter</td></tr><tr><td align="left">“</td><td align="left">单引号</td><td align="left">`</td></tr></tbody></table><h3 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h3><p>printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p><table><thead><tr><th align="left">转 换 符</th><th align="left">说  明</th><th align="left">示  例</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">包括全部日期和时间信息</td><td align="left">星期六 十月 27 14:21:20 CST 2007</td></tr><tr><td align="left">F</td><td align="left">“年-月-日”格式</td><td align="left">2007-10-27</td></tr><tr><td align="left">D</td><td align="left">“月/日/年”格式</td><td align="left">10/27/07</td></tr><tr><td align="left">r</td><td align="left">“HH:MM:SS PM”格式（12时制）</td><td align="left">02:25:51 下午</td></tr><tr><td align="left">T</td><td align="left">“HH:MM:SS”格式（24时制）</td><td align="left">14:28:16</td></tr><tr><td align="left">R</td><td align="left">“HH:MM”格式（24时制）</td><td align="left">14:28</td></tr></tbody></table><pre><code class="java">Date date = new Date();//c的使用  全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          //f的使用  年-月-日格式：2012-09-10  System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  //d的使用  月/日/年格式：09/10/12  System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  //r的使用  HH:MM:SS PM格式（12时制）：10:43:36 上午  System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  //t的使用  HH:MM:SS格式（24时制）：10:43:36  System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  //R的使用  HH:MM格式（24时制）：10:43  System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </code></pre><h3 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h3><pre><code class="java">//下面的一个例子表明如何测量时间间隔（以毫秒为单位）：import java.util.*;public class DiffDemo &#123;    public static void main(String args[]) &#123;      try &#123;         long start = System.currentTimeMillis( );         System.out.println(new Date( ) + &quot;\n&quot;);         Thread.sleep(5*60*10);         System.out.println(new Date( ) + &quot;\n&quot;);         long end = System.currentTimeMillis( );         long diff = end - start;         System.out.println(&quot;Difference is : &quot; + diff);      &#125; catch (Exception e) &#123;         System.out.println(&quot;Got an exception!&quot;);      &#125;   &#125;&#125;</code></pre><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p><pre><code class="java">//创建一个代表系统当前日期的Calendar对象Calendar c = Calendar.getInstance();//默认是当前日期</code></pre><p>创建一个指定日期的Calendar对象</p><p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p><pre><code class="java">//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 , 12);</code></pre><h4 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h4><p>Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Calendar.YEAR</td><td align="left">年份</td></tr><tr><td align="left">Calendar.MONTH</td><td align="left">月份</td></tr><tr><td align="left">Calendar.DATE</td><td align="left">日期</td></tr><tr><td align="left">Calendar.DAY_OF_MONTH</td><td align="left">日期，和上面的字段意义完全相同</td></tr><tr><td align="left">Calendar.HOUR</td><td align="left">12小时制的小时</td></tr><tr><td align="left">Calendar.HOUR_OF_DAY</td><td align="left">24小时制的小时</td></tr><tr><td align="left">Calendar.MINUTE</td><td align="left">分钟</td></tr><tr><td align="left">Calendar.SECOND</td><td align="left">秒</td></tr><tr><td align="left">Calendar.DAY_OF_WEEK</td><td align="left">星期几</td></tr></tbody></table><pre><code class="java">Calendar c1 = Calendar.getInstance();c1.set(2009, 6, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12//把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算c1.set(Calendar.DATE,10);//把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算c1.set(Calendar.YEAR,2008);</code></pre><h4 id="Add设置"><a href="#Add设置" class="headerlink" title="Add设置"></a><strong>Add设置</strong></h4><pre><code class="java">Calendar c1 = Calendar.getInstance();//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, 10);//把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, -10);//其他字段属性的add的意义以此类推</code></pre><h4 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h4><pre><code class="java">Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK);</code></pre><h3 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。</p><p>下面列出GregorianCalendar对象的几个构造方法：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>构造函数和说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>GregorianCalendar()</strong> 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。</td></tr><tr><td>2</td><td><strong>GregorianCalendar(int year, int month, int date)</strong> 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar</td></tr><tr><td>3</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute)</strong> 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td>4</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute, int second)</strong>  为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td>5</td><td><strong>GregorianCalendar(Locale aLocale)</strong> 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td>6</td><td><strong>GregorianCalendar(TimeZone zone)</strong> 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td>7</td><td><strong>GregorianCalendar(TimeZone zone, Locale aLocale)</strong>  在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr></tbody></table><p>这里是GregorianCalendar 类提供的一些有用的方法列表：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>方法和说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>void add(int field, int amount)</strong> 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。</td></tr><tr><td>2</td><td><strong>protected void computeFields()</strong> 转换UTC毫秒值为时间域值</td></tr><tr><td>3</td><td><strong>protected void computeTime()</strong> 覆盖Calendar ，转换时间域值为UTC毫秒值</td></tr><tr><td>4</td><td><strong>boolean equals(Object obj)</strong> 比较此 GregorianCalendar 与指定的 Object。</td></tr><tr><td>5</td><td><strong>int get(int field)</strong> 获取指定字段的时间值</td></tr><tr><td>6</td><td><strong>int getActualMaximum(int field)</strong> 返回当前日期，给定字段的最大值</td></tr><tr><td>7</td><td><strong>int getActualMinimum(int field)</strong> 返回当前日期，给定字段的最小值</td></tr><tr><td>8</td><td><strong>int getGreatestMinimum(int field)</strong>  返回此 GregorianCalendar 实例给定日历字段的最高的最小值。</td></tr><tr><td>9</td><td><strong>Date getGregorianChange()</strong> 获得格里高利历的更改日期。</td></tr><tr><td>10</td><td><strong>int getLeastMaximum(int field)</strong> 返回此 GregorianCalendar 实例给定日历字段的最低的最大值</td></tr><tr><td>11</td><td><strong>int getMaximum(int field)</strong> 返回此 GregorianCalendar 实例的给定日历字段的最大值。</td></tr><tr><td>12</td><td><strong>Date getTime()</strong> 获取日历当前时间。</td></tr><tr><td>13</td><td><strong>long getTimeInMillis()</strong> 获取用长整型表示的日历的当前时间</td></tr><tr><td>14</td><td><strong>TimeZone getTimeZone()</strong> 获取时区。</td></tr><tr><td>15</td><td><strong>int getMinimum(int field)</strong> 返回给定字段的最小值。</td></tr><tr><td>16</td><td><strong>int hashCode()</strong> 重写hashCode.</td></tr><tr><td>17</td><td><strong>boolean isLeapYear(int year)</strong> 确定给定的年份是否为闰年。</td></tr><tr><td>18</td><td><strong>void roll(int field, boolean up)</strong> 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</td></tr><tr><td>19</td><td><strong>void set(int field, int value)</strong> 用给定的值设置时间字段。</td></tr><tr><td>20</td><td><strong>void set(int year, int month, int date)</strong> 设置年、月、日的值。</td></tr><tr><td>21</td><td><strong>void set(int year, int month, int date, int hour, int minute)</strong> 设置年、月、日、小时、分钟的值。</td></tr><tr><td>22</td><td><strong>void set(int year, int month, int date, int hour, int minute, int second)</strong> 设置年、月、日、小时、分钟、秒的值。</td></tr><tr><td>23</td><td><strong>void setGregorianChange(Date date)</strong> 设置 GregorianCalendar 的更改日期。</td></tr><tr><td>24</td><td><strong>void setTime(Date date)</strong> 用给定的日期设置Calendar的当前时间。</td></tr><tr><td>25</td><td><strong>void setTimeInMillis(long millis)</strong> 用给定的long型毫秒数设置Calendar的当前时间。</td></tr><tr><td>26</td><td><strong>void setTimeZone(TimeZone value)</strong> 用给定时区值设置当前时区。</td></tr><tr><td>27</td><td><strong>String toString()</strong> 返回代表日历的字符串。</td></tr></tbody></table><h2 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h2><p>正则表达式定义了字符串的模式。</p><p>正则表达式可以用来搜索、编辑或处理文本。</p><p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。一个字符串其实就是一个简单的正则表达式，例如 <strong>Hello World</strong> 正则表达式匹配 “Hello World” 字符串。</p><p>**.**（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。</p><p>下表列出了一些正则表达式的实例及描述：</p><table><thead><tr><th align="left">正则表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">this is text</td><td align="left">匹配字符串 “this is text”</td></tr><tr><td align="left">this\s+is\s+text</td><td align="left">注意字符串中的 **\s+**。匹配单词 “this” 后面的 <strong>\s+</strong> 可以匹配多个空格，之后匹配 is 字符串，再之后 <strong>\s+</strong> 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td></tr><tr><td align="left">^\d+(.\d+)?</td><td align="left">^ 定义了以什么开始\d+ 匹配一个或多个数字? 设置括号内的选项是可选的. 匹配 “.”可以匹配的实例：”5”, “1.5” 和 “2.21”。</td></tr></tbody></table><p>Java 正则表达式和 Perl 的是最为相似的。</p><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p><strong>Pattern 类：</strong></p><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><strong>Matcher 类：</strong></p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p><strong>PatternSyntaxException：</strong></p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><pre><code class="java">import java.util.regex.*; class RegexExample1&#123;   public static void main(String[] args)&#123;      String content = &quot;I am noob &quot; +        &quot;from runoob.com.&quot;;       String pattern = &quot;.*runoob.*&quot;;       boolean isMatch = Pattern.matches(pattern, content);      System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch);   &#125;&#125;</code></pre><h3 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h3><p>捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。</p><p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p><ul><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ul><p>调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p><p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p><pre><code class="java">import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123;    public static void main( String[] args )&#123;       // 按指定模式在字符串查找      String line = &quot;This order was placed for QT3000! OK?&quot;;      String pattern = &quot;(\\D*)(\\d+)(.*)&quot;;       // 创建 Pattern 对象      Pattern r = Pattern.compile(pattern);       // 现在创建 matcher 对象      Matcher m = r.matcher(line);      if (m.find( )) &#123;         System.out.println(&quot;Found value: &quot; + m.group(0) );         System.out.println(&quot;Found value: &quot; + m.group(1) );         System.out.println(&quot;Found value: &quot; + m.group(2) );         System.out.println(&quot;Found value: &quot; + m.group(3) );       &#125; else &#123;         System.out.println(&quot;NO MATCH&quot;);      &#125;   &#125;&#125;</code></pre><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>在 Java 中，<strong>\** 表示：</strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。**</p><p>所以，在其他的语言中（如 Perl），一个反斜杠 *<em>*</em> 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 *<em>\*</em> 代表其他语言中的一个 ****，这也就是为什么表示一位数字的正则表达式是 <strong>\d</strong>，而表示一个普通的反斜杠是 **\**。</p><table><thead><tr><th align="left">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong>n</strong>匹配字符 <strong>n</strong>。<strong>\n</strong> 匹配换行符。序列 <strong>\\** 匹配 *<em>\*</em> ，</strong>\(** 匹配 **(**。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr><tr><td align="left">*</td><td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td align="left">+</td><td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td align="left">{<em>n</em>}</td><td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td align="left">{<em>n</em>,}</td><td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td align="left">{<em>n</em>,<em>m</em>}</td><td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td align="left">?</td><td align="left">当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td></tr><tr><td align="left">.</td><td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td></tr><tr><td align="left">(<em>pattern</em>)</td><td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td></tr><tr><td align="left">(?:<em>pattern</em>)</td><td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td></tr><tr><td align="left">(?=<em>pattern</em>)</td><td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="left">(?!<em>pattern</em>)</td><td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="left"><em>x</em>|<em>y</em></td><td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td></tr><tr><td align="left">[<em>xyz</em>]</td><td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td></tr><tr><td align="left">[^<em>xyz</em>]</td><td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td></tr><tr><td align="left">[<em>a-z</em>]</td><td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td></tr><tr><td align="left">[^<em>a-z</em>]</td><td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td></tr><tr><td align="left">\B</td><td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td></tr><tr><td align="left">\c<em>x</em></td><td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td></tr><tr><td align="left">\d</td><td align="left">数字字符匹配。等效于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td align="left">\t</td><td align="left">制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td align="left">\w</td><td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td></tr><tr><td align="left">\W</td><td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td></tr><tr><td align="left">\x<em>n</em></td><td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td align="left">*num*</td><td align="left">匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td></tr><tr><td align="left">*n*</td><td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td></tr><tr><td align="left">*nm*</td><td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td></tr><tr><td align="left">\nml</td><td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td></tr><tr><td align="left">\u<em>n</em></td><td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr></tbody></table><h3 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h3><h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public int start()</strong> 返回以前匹配的初始索引。</td></tr><tr><td align="left">2</td><td align="left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td align="left">3</td><td align="left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td></tr><tr><td align="left">4</td><td align="left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table><h4 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h4><p>查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public boolean lookingAt()</strong>  尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td align="left">2</td><td align="left"><strong>public boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td align="left">3</td><td align="left"><strong>public boolean find(int start****）</strong> 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td align="left">4</td><td align="left"><strong>public boolean matches()</strong> 尝试将整个区域与模式匹配。</td></tr></tbody></table><h4 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h4><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td></tr><tr><td align="left">2</td><td align="left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td></tr><tr><td align="left">3</td><td align="left"><strong>public String replaceAll(String replacement)</strong>  替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td align="left">4</td><td align="left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td align="left">5</td><td align="left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td></tr></tbody></table><h4 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start 和 end 方法"></a>start 和 end 方法</h4><pre><code class="java">//start 和 end 方法import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123;    private static final String REGEX = &quot;\\bcat\\b&quot;;//使用单词边界，以确保字母 &quot;c&quot; &quot;a&quot; &quot;t&quot; 并非仅是一个较长的词的子串。    private static final String INPUT =                                    &quot;cat cat cat cattie cat&quot;;     public static void main( String[] args )&#123;       Pattern p = Pattern.compile(REGEX);       Matcher m = p.matcher(INPUT); // 获取 matcher 对象       int count = 0;        while(m.find()) &#123;         count++;         System.out.println(&quot;Match number &quot;+count);         System.out.println(&quot;start(): &quot;+m.start());         System.out.println(&quot;end(): &quot;+m.end());      &#125;   &#125;&#125;/**输出Match number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22*/</code></pre><h4 id="matches-和-lookingAt-方法"><a href="#matches-和-lookingAt-方法" class="headerlink" title="matches 和 lookingAt 方法"></a>matches 和 lookingAt 方法</h4><p>matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。 matches 要求整个序列都匹配，而lookingAt 不要求。lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。</p><ol><li><pre><code class="java">import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123;    private static final String REGEX = &quot;foo&quot;;    private static final String INPUT = &quot;fooooooooooooooooo&quot;;    private static final String INPUT2 = &quot;ooooofoooooooooooo&quot;;    private static Pattern pattern;    private static Matcher matcher;    private static Matcher matcher2;     public static void main( String[] args )&#123;       pattern = Pattern.compile(REGEX);       matcher = pattern.matcher(INPUT);       matcher2 = pattern.matcher(INPUT2);        System.out.println(&quot;Current REGEX is: &quot;+REGEX);       System.out.println(&quot;Current INPUT is: &quot;+INPUT);       System.out.println(&quot;Current INPUT2 is: &quot;+INPUT2);         System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt());       System.out.println(&quot;matches(): &quot;+matcher.matches());       System.out.println(&quot;lookingAt(): &quot;+matcher2.lookingAt());   &#125;&#125;/**输出REGEX is: fooCurrent INPUT is: foooooooooooooooooCurrent INPUT2 is: ooooofoooooooooooolookingAt(): truematches(): falselookingAt(): false*/</code></pre></li></ol><h4 id="replaceFirst-和-replaceAll-方法"><a href="#replaceFirst-和-replaceAll-方法" class="headerlink" title="replaceFirst 和 replaceAll 方法"></a>replaceFirst 和 replaceAll 方法</h4><p>replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</p><pre><code class="java">import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123;    private static String REGEX = &quot;dog&quot;;    private static String INPUT = &quot;The dog says meow. &quot; +                                    &quot;All dogs say meow.&quot;;    private static String REPLACE = &quot;cat&quot;;     public static void main(String[] args) &#123;       Pattern p = Pattern.compile(REGEX);       // get a matcher object       Matcher m = p.matcher(INPUT);        INPUT = m.replaceAll(REPLACE);       System.out.println(INPUT);       &#125;    /*输出    The cat says meow. All cats say meow.    */</code></pre><h4 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h4><pre><code class="java">private static String REGEX = &quot;a*b&quot;;private static String INPUT = &quot;aabfooaabfooabfoobkkk&quot;;private static String REPLACE = &quot;-&quot;;Pattern p = Pattern.compile(REGEX);Matcher m = p.matcher(INPUT);      StringBuffer sb = new StringBuffer();      while(m.find())&#123;         m.appendReplacement(sb,REPLACE);      &#125;      m.appendTail(sb);      System.out.println(sb.toString());/*输出-foo-foo-foo-kkk*/</code></pre><h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><p> <strong>System.out.println()</strong></p><ul><li>println() 是一个方法。</li><li>System 是系统类。</li><li>out 是标准输出对象。</li></ul><p>这句话调用系统类 System 中的标准输出对象 out 中的方法 println()</p><p>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。</p><p>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>一个类的两个方法拥有相同的名字，但是有不同的参数列表。Java编译器根据方法签名判断哪个方法应该被调用。</p><pre><code class="java">public static double max(double num1, double num2) &#123;  if (num1 &gt; num2)    return num1;  else    return num2;&#125;</code></pre><p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p><h3 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h3><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><p>命令行参数是在执行程序时候紧跟在程序名字后面的信息。</p><pre><code class="java">public class CommandLine &#123;   public static void main(String args[])&#123;       for(int i=0; i&lt;args.length; i++)&#123;         System.out.println(&quot;args[&quot; + i + &quot;]: &quot; + args[i]);      &#125;   &#125;&#125;</code></pre><p>运行这个程序：</p><pre><code class="java">$ javac CommandLine.java $ java CommandLine this is a command line 200 -100args[0]: thisargs[1]: isargs[2]: aargs[3]: commandargs[4]: lineargs[5]: 200args[6]: -100</code></pre><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p><p>所有的类都有构造方法，Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。一旦你定义了自己的构造方法，默认构造方法就会失效。</p><pre><code class="java">// 一个无参构造class MyClass &#123;  int x;   // 以下是构造函数  MyClass() &#123;    x = 10;  &#125;&#125;    MyClass t1 = new MyClass( 10 );    MyClass t2 = new MyClass( 20 );    System.out.println(t1.x + &quot; &quot; + t2.x);// 有参构造class MyClass &#123;  int x;   // 以下是构造函数  MyClass(int i ) &#123;    x = i;  &#125;&#125;调用有参构造来初始化对象    MyClass t1 = new MyClass( 10 );    MyClass t2 = new MyClass( 20 );</code></pre><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则选择固定参数的方法。</p><p><strong>避免带有可变长参数的方法重载</strong></p><pre><code class="java">public class VarargsDemo &#123;    public static void main(String args[]) &#123;        // 调用可变参数的方法        printMax(34, 3, 3, 2, 56.5);        printMax(new double[]&#123;1, 2, 3&#125;);    &#125;     public static void printMax( double... numbers) &#123;//可变参数        if (numbers.length == 0) &#123;            System.out.println(&quot;No argument passed&quot;);            return;        &#125;         double result = numbers[0];         for (int i = 1; i &lt;  numbers.length; i++)&#123;            if (numbers[i] &gt;  result) &#123;                result = numbers[i];            &#125;        &#125;        System.out.println(&quot;The max value is &quot; + result);    &#125;&#125;</code></pre><h3 id="finalize-方法（类似析构函数）"><a href="#finalize-方法（类似析构函数）" class="headerlink" title="finalize() 方法（类似析构函数）"></a>finalize() 方法（类似析构函数）</h3><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p><pre><code class="java">protected void finalize()&#123;   // 在这里终结代码&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于opencv的视频监控系统</title>
      <link href="2020/09/21/%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/09/21/%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> -占位 -暂无内容 -opencv -c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt5学习笔记(一)</title>
      <link href="2020/08/21/qt_learning_1/"/>
      <url>2020/08/21/qt_learning_1/</url>
      
        <content type="html"><![CDATA[<h2 id="初见QT"><a href="#初见QT" class="headerlink" title="初见QT"></a>初见QT</h2><pre><code>        qt的主要模块</code></pre><p>​    <img src="/images/qt1.jpg" alt="image-20210322112141675"></p><p>​                                  创建的项目中的pro文件内容</p><p>.pro基本上是构建工程项目时由Qt处理的第一个文件，这个文件称为Qt项目文件，一个名为“qmake”的内部Qt程序负责处理该文件</p><pre><code class="c++">QT       += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgets //版本大于4以上，使用widgets类，更好的兼容性TARGET = opencv2 //目标  生成的exe可执行文件的名称TEMPLATE = app  //工程所使用的模板DEFINES += QT_DEPRECATED_WARNINGSCONFIG += c++11SOURCES += \                    //源文件        main.cpp \        mainwindow.cppHEADERS += \            //头文件        mainwindow.hFORMS += \                      //ui文件        mainwindow.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target        </code></pre><h3 id="qt命名规范与快捷键"><a href="#qt命名规范与快捷键" class="headerlink" title="qt命名规范与快捷键"></a>qt命名规范与快捷键</h3><p>​    类名：首字母大写 单词与单词之间 首字母大写</p><p>​    函数、变量：首字母小写，单词与单词之间 首字母大写</p><p>快捷键：</p><p>​    运行 ctrl+ R</p><p>​    编译 ctrl + B</p><p>​    查找 ctrl + F</p><p>   帮助文档 第一种: F1 第二种 ：旁边的帮助按钮 第三种：assistant.exe      查看选中类及函数，esc退出</p><p>​    字体缩放 ctrl + 鼠标滚轮</p><p>​    自动对齐 ctrl + i</p><p>​    整行移动 ctrl + shift + 上 或者下</p><p>​    同名之间的 .h  .cpp 切换  F4<br>​    </p><p>使用新类时，要查看该类所属的模块是否包含在工程pro文件中第一行<br>    QT       += core gui network</p><p>show用顶层方式弹出，如果想在MyWidget窗口中显示，就需要依赖MyWidget 窗口， 设置 MyWidget为父亲</p><p>案例一 qt_opecv</p><h4 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h4><p><img src="/images/qt1.png" alt="qt1"></p><h4 id="pro文件"><a href="#pro文件" class="headerlink" title=".pro文件"></a>.pro文件</h4><pre><code class="c++">    #-------------------------------------------------## Project created by QtCreator 2021-03-23T21:10:27##-------------------------------------------------QT       += core gui  //项目使用的模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //在4版本以上的qt中使用widgets模块TARGET = qt_opencv2  //生成的exe文件名TEMPLATE = app  //项目使用的模板# The following define makes your compiler emit warnings if you use# any feature of Qt which has been marked as deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if you use deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0CONFIG += c++11SOURCES += \             //源文件        main.cpp \        mainwindow.cppHEADERS += \              //头文件        mainwindow.hFORMS += \            //ui文件        mainwindow.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += targetinclude(&quot;c:/opencv/opencv.pri&quot;)  //包含opencv库RESOURCES += \            //项目所使用的资源文件（图片，音频等）    resources.qrc</code></pre><h4 id="在-pr中包含的opencv-pri文件"><a href="#在-pr中包含的opencv-pri文件" class="headerlink" title="在.pr中包含的opencv.pri文件"></a>在.pr中包含的opencv.pri文件</h4><pre><code class="c++">INCLUDEPATH += c:\opencv\qt_build\install\includeCONFIG(debug, debug|release): &#123;LIBS += c:\opencv\qt_build\install\x64\mingw\bin\libopencv_*d.dll&#125; else:CONFIG(release, debug|release): &#123;LIBS += -Lc:\opencv\qt_build\install\x64\mingw\bin\    -llibopencv_core451 \    -llibopencv_highgui451 \    -llibopencv_imgcodecs451 \    -llibopencv_imgproc451 \    -llibopencv_features2d451 \    -llibopencv_calib3d451&#125;</code></pre><h4 id="mainwindow-h"><a href="#mainwindow-h" class="headerlink" title="mainwindow.h"></a>mainwindow.h</h4><p>​    这个头文件定义了mainwindow类，以及他的函数，也包含了mainwindow.cpp所需的头文件</p><pre><code class="c++">#ifndef MAINWINDOW_H  //与文件尾部#endif // MAINWINDOW_H 共同起到了防止重复包含#define MAINWINDOW_H#include&lt;QDir&gt;#include&lt;QFile&gt;#include &lt;QMainWindow&gt;#include &lt;QFileDialog&gt;#include&lt;opencv2/opencv.hpp&gt;#include &lt;QMessageBox&gt;#include &lt;QCloseEvent&gt;#include &lt;QSettings&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123;    Q_OBJECT  //qt文件的基类public:    explicit MainWindow(QWidget *parent = nullptr);    ~MainWindow();private slots:    void on_inputPushButton_pressed(); //qt中的槽函数，    void on_outputPushButton_pressed();private:    Ui::MainWindow *ui;    void loadSettings();     //加载设置    void saveSettings();    //保存设置protected:    void closeEvent(QCloseEvent *event); //确认关闭窗口退出程序&#125;;#endif // MAINWINDOW_H</code></pre><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><p>​    main函数，程序的入口</p><pre><code class="c++">#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt; //负责控制应用程序的控制流、设置等的主要类int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);  //创建了QApplication类的一个实例，并将应用程序的参数（通常通过命令行或者终端传递）传递给    //名为a的实例    MainWindow w; //mainwindow类的实例w    w.show();//调用show（）显示该实例    return a.exec();//调用QApplication类的exec()函数，以便应用程序进入主循环，并一直保持到窗口关闭为止&#125;</code></pre><h4 id="mainwindow-cpp"><a href="#mainwindow-cpp" class="headerlink" title="mainwindow.cpp"></a>mainwindow.cpp</h4><p>​        包含mainwindow类各种方法的实现，信号槽函数的实现</p><pre><code></code></pre><pre><code class="c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;  //qt的uic编译的ui文件的头文件#include&lt;opencv2/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;MainWindow::MainWindow(QWidget *parent) : //mainwindow的构造函数实现,参数列表    QMainWindow(parent),    //以Qmainwindow类为父容器    ui(new Ui::MainWindow)   //&#123;    ui-&gt;setupUi(this);    loadSettings();    //加载设置，具体实现在下方&#125;MainWindow::~MainWindow() //析构&#123;    delete ui;&#125;void MainWindow::on_inputPushButton_pressed()   //inputPushButton的槽函数具体实现&#123;    QString filename = QFileDialog::getOpenFileName(this,                                                    &quot;Open Input Image&quot;,                                                    QDir::currentPath(),                                                    &quot;Images (*.jpg *.png *.bmp *.tiff)&quot;);    if(QFile::exists(filename))    &#123;        ui-&gt;inputLineEdit-&gt;setText(filename);    &#125;&#125;void MainWindow::on_outputPushButton_pressed()&#123;    QString fileName = QFileDialog::getSaveFileName(this,                                                    &quot;Select Output Image&quot;,                                                    QDir::currentPath(),                                                    &quot;*.JPG ;;*.PNG;;*.BMP;;*.TIFF&quot;);    if(!fileName.isEmpty())&#123;        ui-&gt;outputLineEdit-&gt;setText(fileName);        using namespace  cv;        Mat inpImg, outImg;        inpImg = imread(ui-&gt;inputLineEdit-&gt;text().toStdString());        if(ui-&gt;medianBlurRadioButton-&gt;isChecked())            cv::medianBlur(inpImg,outImg,5);        else if (ui-&gt;gaussianBlurRadioButton-&gt;isChecked())            cv::GaussianBlur(inpImg,outImg,Size(5,5),1.25);        imwrite(fileName.toStdString(),outImg);        if(ui-&gt;displayImageCheckBox-&gt;isChecked())            imshow(&quot;Output image&quot;,outImg);    &#125;&#125;void MainWindow::loadSettings()&#123;    QSettings settings(&quot;Packt&quot;,                      &quot;qt_opencv2&quot;,                      this);    ui-&gt;inputLineEdit-&gt;setText(settings.value(&quot;inputLineEdit&quot;,&quot;&quot;).toString());    ui-&gt;outputLineEdit-&gt;setText(settings.value(&quot;outputLineEdit&quot;,&quot;&quot;).toString());    ui-&gt;medianBlurRadioButton-&gt;setChecked(settings.value(&quot;medianBlurRadioButton&quot;,true).toBool());    ui-&gt;gaussianBlurRadioButton-&gt;setChecked(settings.value(&quot;gaussianBlurRadioButtin&quot;,false).toBool());    ui-&gt;displayImageCheckBox-&gt;setChecked(settings.value(&quot;displayImageCheckBox&quot;,false).toBool());&#125;void MainWindow::saveSettings()&#123;    QSettings settings(&quot;Packt&quot;,                      &quot;qt_opencv2&quot;,                       this);    settings.setValue(&quot;inputLIneEdit&quot;,ui-&gt;inputLineEdit-&gt;text());    settings.setValue(&quot;outputLineEdit&quot;,ui-&gt;outputLineEdit-&gt;text());    settings.setValue(&quot;medianBlurRadioButton&quot;,ui-&gt;medianBlurRadioButton-&gt;isChecked());    settings.setValue(&quot;gaussianBlurRadioButton&quot;,ui-&gt;gaussianBlurRadioButton-&gt;isChecked());    settings.setValue(&quot;displayImageCheckBox&quot;,ui-&gt;displayImageCheckBox-&gt;isChecked());&#125;void MainWindow::closeEvent(QCloseEvent *event)&#123;    int result = QMessageBox::warning(this,                                      &quot;Exit&quot;,                                      &quot;Are you sure you want to close this program?&quot;,                                      QMessageBox::Yes,                                      QMessageBox::No);    if(result == QMessageBox::Yes)    &#123;        saveSettings();        event-&gt;accept();    &#125;    else &#123;        &#123;            event-&gt;ignore();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> opencv </tag>
            
            <tag> gui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bilibili视频下载器</title>
      <link href="2019/09/21/Bilibili%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
      <url>2019/09/21/Bilibili%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="bilibil视频下载器"><a href="#bilibil视频下载器" class="headerlink" title="bilibil视频下载器"></a>bilibil视频下载器</h2><p>​    主要是想下载自己收藏夹。使用python编写的代码，简单易懂。登录的信息以及登录全过程仅涉及自己的主机以及B站，代码开源，github地址为<a href="https://zqy000.github.io/">bilibili视频下载器</a>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> qt </tag>
            
            <tag> bilibili </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记（一）</title>
      <link href="2019/07/27/c-learning/"/>
      <url>2019/07/27/c-learning/</url>
      
        <content type="html"><![CDATA[<h3 id="c语言学习笔记-一"><a href="#c语言学习笔记-一" class="headerlink" title="c语言学习笔记(一)"></a>c语言学习笔记(一)</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h5><p>我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p><pre><code class="c++">class Box&#123;   public:      double length;   // 盒子的长度      double breadth;  // 盒子的宽度      double height;   // 盒子的高度&#125;;</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png" alt="类定义"></p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><pre><code class="C++">C::C( double a, double b, double c): X(a), Y(b), Z(c) &#123;  .... &#125;</code></pre><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>  拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p><ul><li><p>通过使用另一个同类型的对象来初始化新创建的对象。</p></li><li><p>复制对象把它作为参数传递给函数。</p></li><li><p>复制对象，并从函数返回这个对象。</p></li><li><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p><pre><code class="c++">Line::Line(const Line &amp;obj)&#123;    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;    ptr = new int;    *ptr = *obj.ptr; // 拷贝值&#125; Line::~Line(void)&#123;    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;    delete ptr;&#125;</code></pre></li></ul><h4 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h4><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li><p>基于进程的多任务处理是程序的并发执行。</p></li><li><p>基于线程的多任务处理是同一程序的片段的并发执行</p><h6 id="c-11-新类-thread"><a href="#c-11-新类-thread" class="headerlink" title="c++11 新类 thread"></a>c++11 新类 thread</h6><p>detch()启动线程： detch()方法的意思就是开启子线程，并且主线程不等待子线程运行完毕，而是和子线程并行运行。</p></li></ul><p>join()方法启动线程：join()方法的意思就是开启子线程，线程会按照开启的先后顺序同步运行。</p><pre><code class="c++">#include &lt;thread&gt;#include &lt;Windows.h&gt;using namespace std;void TestThread1();void TestThread2();int main()&#123;  thread t1(TestThread1);        t1.detach();  //t1.join();    thread t2(TestThread2);    t2.detach();  //t2.join();    printf(&quot;主线程：你好帅！！！！\n&quot;);  system(&quot;pause&quot;);&#125;void TestThread1()&#123;    for (int i = 0; i &lt; 10; i++)&#123;        printf(&quot;TestThread1:%d\n&quot;, i);        Sleep(100);    &#125;&#125;void TestThread2()&#123;    for (int i = 100; i &lt; 110; i++)&#123;        printf(&quot;TestThread2:%d\n&quot;, i);        Sleep(100);    &#125;&#125;</code></pre><p>  <strong>子线程函数带有参数的多线程：</strong></p><pre><code class="c++">#include &lt;thread&gt;#include &lt;Windows.h&gt;using namespace std;void TestThread1(int count);void TestThread2(int start ,int count);int main()&#123;    thread t1(TestThread1,10);    t1.detach();    thread t2(TestThread2,40,50);    t2.detach();    printf(&quot;主线程：你好帅！！！！\n&quot;);    system(&quot;pause&quot;);&#125;void TestThread1(int count)&#123;    for (int i = 0; i &lt; count; i++)&#123;        printf(&quot;TestThread1:%d\n&quot;, i);        Sleep(100);    &#125;&#125;void TestThread2(int start,int count)&#123;    for (int i = start; i &lt; count; i++)&#123;        printf(&quot;TestThread2:%d\n&quot;, i);        Sleep(100);    &#125;&#125;</code></pre><p>多线程安全访问共享数据例子（卖票）<br>ThreadTest.h头文件</p><pre><code class="c++">#ifndef _THREAD_TEST_H_#define _THREAD_TEST_H_#include &lt;stdio.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;Windows.h&gt;using namespace std;class ThreadTest&#123;public:    //卖票线程1    void hread1();    //卖票线程2    void hread2();    ThreadTest();    ~ThreadTest();private:    //票的剩余数目    int Sum;    mutex Mutex;//线程锁&#125;;#endif // !_THREAD_TEST_H_</code></pre><p>ThreadTest.cpp 文件</p><pre><code class="c++">#include &quot;test.h&quot;using namespace std;void ThreadTest::hread1() &#123;    for (;;) &#123;        Mutex.lock();//加锁        Sleep(10);        --Sum;        if (Sum &lt; 0) &#123;            printf(&quot;Thrad1——票卖完了\n&quot;, Sum);            break;        &#125;        printf(&quot;Thrad1——剩余票数：%d\n&quot;, Sum);        Mutex.unlock();//解锁    &#125;    Mutex.unlock();//解锁&#125;void  ThreadTest::hread2() &#123;    for (;;) &#123;        Mutex.lock();//加锁               Sleep(10);        --Sum;        if (Sum &lt; 0) &#123;            printf(&quot;Thrad2——票卖完了\n&quot;);            break;        &#125;        printf(&quot;Thrad2——剩余票数：%d\n&quot;, Sum);        Mutex.unlock();//解锁    &#125;    Mutex.unlock();//解锁&#125;//构造函数ThreadTest::ThreadTest()&#123;    Sum = 50;    thread t1(&amp;ThreadTest::hread1, this);    t1.detach();    thread t2(&amp;ThreadTest::hread2, this);    t2.detach();&#125;//析构函数ThreadTest::~ThreadTest()&#123;&#125;</code></pre><p>main</p><pre><code class="c++">#include &quot;test.h&quot;int main() &#123;    //多线程卖票类    ThreadTest SaleThread;    while (true) &#123;        //为了截图方便--加入死循环    &#125;&#125;</code></pre><h1 id="include-pthread库"><a href="#include-pthread库" class="headerlink" title="include //pthread库"></a>include<pthread> //pthread库</h1><pre><code class="c++">#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) </code></pre><table><thead><tr><th>thread</th><th align="left">指向线程标识符指针。</th></tr></thead><tbody><tr><td>attr</td><td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td></tr><tr><td>start_routine</td><td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td></tr><tr><td>arg</td><td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td></tr></tbody></table><p>  创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>  使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><pre><code class="c++">#include &lt;pthread.h&gt;pthread_exit (status) </code></pre><p>  如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p><pre><code class="c++">#include &lt;iostream&gt;// 必须的头文件#include &lt;pthread.h&gt; using namespace std; #define NUM_THREADS 5 // 线程的运行函数void* say_hello(void* args)&#123;    cout &lt;&lt; &quot;Hello Runoob！&quot; &lt;&lt; endl;    return 0;&#125; int main()&#123;    // 定义线程的 id 变量，多个变量使用数组    pthread_t tids[NUM_THREADS];    for(int i = 0; i &lt; NUM_THREADS; ++i)    &#123;        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数        int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL);        if (ret != 0)        &#123;           cout &lt;&lt; &quot;pthread_create error: error_code=&quot; &lt;&lt; ret &lt;&lt; endl;        &#125;    &#125;    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；    pthread_exit(NULL);&#125;</code></pre><h5 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h5>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -c++ -C++STL -学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ STL(一)</title>
      <link href="2019/06/27/c-STL/"/>
      <url>2019/06/27/c-STL/</url>
      
        <content type="html"><![CDATA[<h3 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h3><p>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       Vector：</p><p>可以高性能随机访问(使用下标或者at时间复杂度O(1),)，但不适合大量随机插入将或修改元素。</p><p>元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；</p><p>v[10]不进行合理性检测有越界风险，v.at（10）进行合理性检测，安全，建议使用at（）。<br>       Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template.0</p><p>0.</p><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p><h3 id="STL三大组件"><a href="#STL三大组件" class="headerlink" title="STL三大组件"></a>STL三大组件</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>​    常用的数据结构：数组(array),链表(list),tree(树)，栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性，这些数据分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种。</p><p>​     序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p><p>​    关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>  以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms).STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p><p>迭代器的种类:</p><table><thead><tr><th>输入迭代器</th><th>提供对数据的只读访问</th><th>只读，支持++、==、！=</th></tr></thead><tbody><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;//STL 中的容器 算法 迭代器void test01()&#123;    vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组    v.push_back(1); //vector 容器提供的插入数据的方法    v.push_back(5);    v.push_back(3);    v.push_back(7);    //迭代器    vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器    vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;    //算法 count 算法 用于统计元素的个数    int n = count(pStart, pEnd, 5);    cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;&#125;//STL 容器不单单可以存储基础数据类型，也可以存储类对象class Teacher&#123;public:    Teacher(int age) :age(age)&#123;&#125;;    ~Teacher()&#123;&#125;;public:    int age;&#125;;void test02()&#123;    vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器    Teacher t1(10), t2(20), t3(30);    v.push_back(t1);    v.push_back(t2);    v.push_back(t3);    vector&lt;Teacher&gt;::iterator pStart = v.begin();    vector&lt;Teacher&gt;::iterator pEnd = v.end();    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;&#125;//存储 Teacher 类型指针void test03()&#123;    vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针    Teacher* t1 = new Teacher(10);    Teacher* t2 = new Teacher(20);    Teacher* t3 = new Teacher(30);    v.push_back(t1);    v.push_back(t2);    v.push_back(t3);    //拿到容器迭代器    vector&lt;Teacher*&gt;::iterator pStart = v.begin();    vector&lt;Teacher*&gt;::iterator pEnd = v.end();    //通过迭代器遍历    while (pStart != pEnd)&#123;        cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;        pStart++;    &#125;    cout &lt;&lt; endl;&#125;//容器嵌套容器 难点(不理解，可以跳过)void test04()&#123;    vector&lt; vector&lt;int&gt; &gt; v;    vector&lt;int&gt;v1;    vector&lt;int&gt;v2;    vector&lt;int&gt;v3;    for (int i = 0; i &lt; 5;i++)    &#123;        v1.push_back(i);        v2.push_back(i * 10);        v3.push_back(i * 100);    &#125;    v.push_back(v1);    v.push_back(v2);    v.push_back(v3);    for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)    &#123;        for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)        &#123;            cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125; int main()&#123;    //test01();    //test02();    //test03();    test04();    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h4 id="string容器："><a href="#string容器：" class="headerlink" title="string容器："></a>string容器：</h4><p>  #include<string></p><h5 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h5><p>C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。</p><p>String和c风格字符串对比：</p><p>Char*是一个指针，String是一个类</p><p>string封装了char*，管理这个字符串，是一个char*型的容器。</p><p>不用考虑内存释放和越界</p><p> string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p><h6 id="String封装了很多实用的成员方法"><a href="#String封装了很多实用的成员方法" class="headerlink" title="String封装了很多实用的成员方法:"></a>String封装了很多实用的成员方法:</h6><pre><code>查找find：拷贝copy：删除delete：替换replace：插入Insert：</code></pre><h5 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h5><pre><code class="c++">string();//创建一个空的字符串 例如: string str;      string(const string&amp; str);//使用一个string对象初始化另一个string对象string(const char* s);//使用字符串s初始化string(int n, char c);//使用n个字符c初始化 </code></pre><h5 id="string基本赋值操作"><a href="#string基本赋值操作" class="headerlink" title="string基本赋值操作"></a>string基本赋值操作</h5><pre><code class="c++">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串string&amp; operator=(char c);//字符赋值给当前的字符串string&amp; assign(const char *s);//把字符串s赋给当前的字符串string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串string&amp; assign(int n, char c);//用n个字符c赋给当前字符串string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</code></pre><h5 id="string存取字符操作"><a href="#string存取字符操作" class="headerlink" title="string存取字符操作"></a>string存取字符操作</h5><pre><code class="c++">char&amp; operator[](int n);//通过[]方式取字符char&amp; at(int n);//通过at方法获取字符</code></pre><h5 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h5><pre><code class="c++">string&amp; operator+=(const string&amp; str);//重载+=操作符string&amp; operator+=(const char* str);//重载+=操作符string&amp; operator+=(const char c);//重载+=操作符string&amp; append(const char *s);//把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s);//同operator+=()string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</code></pre><h5 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h5><pre><code class="c++">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</code></pre><h5 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h5><pre><code class="c++">/*compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。*/int compare(const string &amp;s) const;//与字符串s比较int compare(const char *s) const;//与字符串s比较</code></pre><h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><pre><code class="c++">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</code></pre><h5 id="string插入和删除操作"><a href="#string插入和删除操作" class="headerlink" title="string插入和删除操作"></a>string插入和删除操作</h5><pre><code class="c++">string&amp; insert(int pos, const char* s); //插入字符串string&amp; insert(int pos, const string&amp; str); //插入字符串string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 </code></pre><h5 id="string和c-style字符串转换"><a href="#string和c-style字符串转换" class="headerlink" title="string和c-style字符串转换"></a>string和c-style字符串转换</h5><pre><code class="c++">//string 转 char*string str = &quot;itcast&quot;;const char* cstr = str.c_str();//char* 转 string char* s = &quot;itcast&quot;;string str(s);</code></pre><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><h5 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h5><p><img src="/images/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p><h5 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h5><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator-&gt;, operator++, operator–, operator+, operator-, operator+=, operator-=, 普通指针天生具备。Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators).</p><p>根据上述描述，如果我们写如下的代码：</p><p>Vector<int>::iterator it1;</p><p>Vector<Teacher>::iterator it2;</p><p>it1的型别其实就是Int*,it2的型别其实就是Teacher*.</p><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 10;i ++)&#123;        v.push_back(i);        cout &lt;&lt; v.capacity() &lt;&lt; endl;  // v.capacity()容器的容量    &#125;    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h4 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h4><p>Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><p>注意&gt; 所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p><h4 id="vector常用API操作"><a href="#vector常用API操作" class="headerlink" title="vector常用API操作"></a>vector常用API操作</h4><h5 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h5><pre><code class="c++">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。vector(n, elem);//构造函数将n个elem拷贝给本身。vector(const vector &amp;vec);//拷贝构造函数。//例子 使用第二个构造函数 我们可以...int arr[] = &#123;2,3,4,1,9&#125;;vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); </code></pre><h5 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h5><pre><code class="c++">size();//返回容器中元素的个数empty();//判断容器是否为空resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。capacity();//容器的容量reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</code></pre><h5 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h5><pre><code class="c++">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。operator[];//返回索引idx所指的数据，越界时，运行直接报错front();//返回容器中第一个数据元素back();//返回容器中最后一个数据元素</code></pre><h5 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h5><pre><code class="c++">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.push_back(ele); //尾部插入元素elepop_back();//删除最后一个元素erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素erase(const_iterator pos);//删除迭代器指向的元素clear();//删除容器中所有元素//c++中vector的排序函数：sort()    int s[] = &#123;1,6,3,2,5&#125;;    vector&lt;int&gt; vec(s, s+5);    //正向排序：按照从小到大的顺序排序    sort(vec.begin(), vec.end());    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    //逆向排序：按照从大到小的顺序进行排序    sort(vec.rbegin(), vec.rend());    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;</code></pre><h5 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h5><pre><code class="c++">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。vector&amp; operator=(const vector  &amp;vec);//重载等号操作符swap(vec);// 将vec与本身的元素互换。</code></pre><h5 id="vector小案例"><a href="#vector小案例" class="headerlink" title="vector小案例"></a>vector小案例</h5><h6 id="巧用swap，收缩内存空间"><a href="#巧用swap，收缩内存空间" class="headerlink" title="巧用swap，收缩内存空间"></a>巧用swap，收缩内存空间</h6><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 100000;i ++)&#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    //此时 通过resize改变容器大小    v.resize(10);cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    //容量没有改变    vector&lt;int&gt;(v).swap(v);    cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;</code></pre><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h4><p>Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><p><img src="/images/clip_image002-1616936871298.jpg" alt="说明: 2015-11-19_204101"></p><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p><p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p><h4 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a>deque容器实现原理</h4><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p><p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><strong><img src="/images/clip_image002-1616937273304.jpg" alt="说明: 2015-11-19_204209"></strong></p><h4 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a>deque常用API</h4><h5 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h5><pre><code class="c++">deque&lt;T&gt; deqT;//默认构造形式deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem);//构造函数将n个elem拷贝给本身。deque(const deque &amp;deq);//拷贝构造函数。</code></pre><h5 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h5><pre><code class="c++">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换</code></pre><h5 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h5><pre><code class="c++">deque.size();//返回容器中元素的个数deque.empty();//判断容器是否为空deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</code></pre><h5 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h5><pre><code class="c++">push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据</code></pre><h5 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h5><pre><code class="c++">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。front();//返回第一个数据。back();//返回最后一个数据</code></pre><h5 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h5><pre><code class="c++">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</code></pre><h5 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h5><pre><code class="c+=">clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。</code></pre><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><pre><code class="c++">//</code></pre><h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h4><p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> c++ </tag>
            
            <tag> C++ STL </tag>
            
            <tag> STL string </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
