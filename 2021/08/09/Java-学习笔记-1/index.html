<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zqy000.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java学习的初级阶段:Java基础语法，类的创建以及使用，基础I&#x2F;O,循环控制、运算符、数组、方法、方法重载。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 学习笔记(1)">
<meta property="og:url" content="https://zqy000.github.io/2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/index.html">
<meta property="og:site_name" content="将进酒">
<meta property="og:description" content="Java学习的初级阶段:Java基础语法，类的创建以及使用，基础I&#x2F;O,循环控制、运算符、数组、方法、方法重载。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zqy000.github.io/images/java1-1.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/20210105-java-object-1.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/java-string-20201208.png">
<meta property="article:published_time" content="2021-08-09T00:41:51.000Z">
<meta property="article:modified_time" content="2021-08-10T09:31:38.590Z">
<meta property="article:author" content="ZQY">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zqy000.github.io/images/java1-1.jpg">

<link rel="canonical" href="https://zqy000.github.io/2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 学习笔记(1) | 将进酒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="将进酒" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">将进酒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">君不见黄河之水天上来，奔流到海不复回。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zqy000" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zqy000.github.io/2021/08/09/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZQY">
      <meta itemprop="description" content="ZQY的博客 |   每一个不曾起舞的日子，都是对生命的辜负。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="将进酒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 学习笔记(1)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-09 08:41:51" itemprop="dateCreated datePublished" datetime="2021-08-09T08:41:51+08:00">2021-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-10 17:31:38" itemprop="dateModified" datetime="2021-08-10T17:31:38+08:00">2021-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">Java学习的初级阶段:Java基础语法，类的创建以及使用，基础I/O,循环控制、运算符、数组、方法、方法重载。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-学习笔记-1"><a href="#Java-学习笔记-1" class="headerlink" title="Java 学习笔记(1)"></a>Java 学习笔记(1)</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        Java最大的优点在于设计之初就秉承了“一次编写，到处运行（Write once,Run Everywhere).”Java语言编写的程序可以在编译后不经任何改动，就能在其他平台上运行，这得益于它的JVM（Java virtual Machine)的机制屏蔽了“翻译”的细节，由JVM负责翻译沟通。</p>
<p><img src="/images/java1-1.jpg" alt="JVM"></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        JVM:Java编译器javac将源代码编译成.class文件，然后通过命令java将.class送往Java虚拟机(JVM)最终变成可执行程序。JVM可以看作是在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上提供给编译器一个共同的接口，编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，将这种供虚拟机理解的代码叫做字节码(Byte Code)，他不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机确实相同的。</p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE(Java Runtime Environment):JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现以及JAVA核心类库。一个Java程序想要运行在Java虚拟机之中，源代码的语句需要由Java编译器编译成字节码。字节码本质上是一种标准化的可移植的二进制格式。改格式以Java类文件.class的形式存在。一个Java程序可以由多个不同的.class文件构成，通常将多个.class文件打包成一个发布文件.jar。其扩展名来自于”java archive”(java归档文件)的简写。</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK(Java Development Kit):Java开发工具包，包括了JRE(Java Runtime Environment)、编译（javac）、解释（java）、打包（jre）等工具还包括开发工具以及开发工具的应用程序接口。</p>
<h2 id="JAVA基础概念"><a href="#JAVA基础概念" class="headerlink" title="JAVA基础概念"></a>JAVA基础概念</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p>
<ul>
<li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
</li>
<li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p>
</li>
<li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p>
</li>
<li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
<pre><code class="java">public class HelloWorld &#123;
    /* 第一个Java程序
     * 它将输出字符串 Hello World
     */
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello World&quot;); // 输出 Hello World
    &#125;
&#125;
</code></pre>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg"></p>
</li>
</ul>
<p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
</ul>
<p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p>
<h4 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a><strong>Java修饰符</strong></h4><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h4 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a><strong>Java 标识符</strong></h4><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
</ul>
<h4 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a><strong>Java 变量</strong></h4><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a><strong>Java 数组</strong></h4><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p>
<h4 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a><strong>Java 枚举</strong></h4><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p>
<h4 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a><strong>Java注释</strong></h4><p>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。空白行或者有注释的行，Java 编译器都会忽略掉。</p>
<pre><code class="java">public class HelloWorld &#123;
   /* 这是第一个Java程序
    * 它将输出 Hello World
    * 这是一个多行注释的示例
    */
    public static void main(String[] args)&#123;
       // 这是单行注释的示例
       /* 这个也是单行注释的示例 */
       System.out.println(&quot;Hello World&quot;); 
    &#125;
&#125;
</code></pre>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h4 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h4><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png"></p>
<h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><p>Java作为一种面向对象语言。支持以下基本概念：</p>
<p>​    多态、继承、封装、抽象、类、对象、实例、方法、重载。</p>
<ul>
<li><p><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
</li>
<li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p>
</li>
</ul>
<p>汽车为类（class），而具体的每辆车为该<strong>汽车</strong>类的<strong>对象（object）</strong>，对象包含了汽车的颜色、品牌、名称等。</p>
<p>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/20210105-java-object-1.png"></p>
<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。static被引入以告知<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>，将变量存储在程序的静态存储区而非栈上空间。static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的存取范围不变。</li>
</ul>
<p>类中的static成员：</p>
<p>一、出现原因及作用：</p>
<p>1、需要在一个类的各个对象间交互，即需要一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">数据对象</a>为整个类而非某个对象服务。</p>
<p>2、同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。</p>
<p>类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。</p>
<p>对于静态的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">数据成员</a>，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，注意<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a>嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p>
<p>类的静态成员函数是属于整个类而非类的对象，所以它没有this<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，这就导致了它仅能访问类的静态数据和静态成员函数。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法（多态：有参构造、无参构造）。</p>
<p>下面是一个构造方法示例：</p>
<pre><code class="java">public class Puppy&#123;
    public Puppy()&#123;
    &#125;
 
    public Puppy(String name)&#123;
        // 这个构造器仅有一个参数：name
    &#125;
&#125;
</code></pre>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<p>下面是一个创建对象的例子：</p>
<pre><code class="java">public class Puppy&#123;
   public Puppy(String name)&#123;
      //这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   &#125;
   public static void main(String[] args)&#123;
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( &quot;tommy&quot; );
   &#125;
&#125;
</code></pre>
<h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p>
<pre><code class="java">public class Puppy&#123;
   int puppyAge;
   public Puppy(String name)&#123;
      // 这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   &#125;
 
   public void setAge( int age )&#123;
       puppyAge = age;
   &#125;
 
   public int getAge( )&#123;
       System.out.println(&quot;小狗的年龄为 : &quot; + puppyAge ); 
       return puppyAge;
   &#125;
 
   public static void main(String[] args)&#123;
      /* 创建对象 */
      Puppy myPuppy = new Puppy( &quot;tommy&quot; );
      /* 通过方法来设定age */
      myPuppy.setAge( 2 );
      /* 调用另一个方法获取age */
      myPuppy.getAge( );
      /*你也可以像下面这样访问成员变量 */
      System.out.println(&quot;变量值 : &quot; + myPuppy.puppyAge ); 
   &#125;
&#125;
</code></pre>
<h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<p>类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。</p>
<p>除了上面提到的几种类型，Java 还有一些特殊的类，如：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-inner-class.html">内部类</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-anonymous-class.html">匿名类</a>。</p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p>byte：8位、有符号</p>
<p>short：16位、有符号</p>
<p>int：32位、有符号、一般地整型变量默认为 int 类型</p>
<p>long：64位、有符号、</p>
<p>float：32位、单精度、浮点数</p>
<p>double：64位、双精度</p>
<p>boolean：1位、取值true或false</p>
<p>char：16位Unicode字符</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>​    在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p>
<ul>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(“Runoob”)。</li>
<li>通常使用大写字母表示常量。</li>
</ul>
<h4 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h4><p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<pre><code class="java">final double PI = 3.1415927;
</code></pre>
<p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：</p>
<pre><code class="java">int decimal = 100;
int octal = 0144;
int hexa =  0x64;
</code></pre>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<pre><code class="java">低  ------------------------------------&gt;  高

byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 
</code></pre>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li>\1. 不能对boolean类型进行类型转换。</li>
<li>\2. 不能把对象类型转换成不相关类的对象。</li>
<li>\3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
<li>\4. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
<li>\5. 转换过程中可能导致溢出或损失精度，例如：</li>
</ul>
<pre><code class="java">int i =128;   
byte b = (byte)i;
</code></pre>
<h2 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h2><p>Java语言支持的变量类型有：</p>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<h4 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h4><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ul>
<h4 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h4><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>Java语言提供了很多修饰符，主要分为以下两类：</p>
<ul>
<li>访问修饰符</li>
<li>非访问修饰符</li>
</ul>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>
<pre><code class="java">public class ClassName &#123;
   // ...
&#125;
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) &#123;
   // 方法体
&#125;
</code></pre>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<p>static 修饰符，用来修饰类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h4><ul>
<li><p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
<li><p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
<p>如下例所示，static修饰符用来创建类方法和类变量。</p>
</li>
</ul>
<pre><code class="java">public class InstanceCounter &#123;
   private static int numInstances = 0;
   protected static int getCount() &#123;
      return numInstances;
   &#125;
 
   private static void addInstance() &#123;
      numInstances++;
   &#125;
 
   InstanceCounter() &#123;
      InstanceCounter.addInstance();
   &#125;
 
   public static void main(String[] arguments) &#123;
      System.out.println(&quot;Starting with &quot; +
      InstanceCounter.getCount() + &quot; instances&quot;);
      for (int i = 0; i &lt; 500; ++i)&#123;
         new InstanceCounter();
          &#125;
      System.out.println(&quot;Created &quot; +
      InstanceCounter.getCount() + &quot; instances&quot;);
   &#125;
&#125;
</code></pre>
<h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><p><strong>final 变量：</strong></p>
<p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<p><strong>final 方法</strong></p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p>如下所示，使用 final 修饰符声明方法。</p>
<pre><code class="java">public class Test&#123;
    public final void changeName()&#123;
       // 方法体
    &#125;
&#125;
</code></pre>
<p><strong>final 类</strong></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h4><p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<pre><code class="java">abstract class Caravan&#123;
   private double price;
   private String model;
   private String year;
   public abstract void goFast(); //抽象方法
   public abstract void changeColor();
&#125;
</code></pre>
<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：**public abstract sample();**。</p>
<h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。用<strong>transient</strong>声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p>
<p><strong>序列化</strong>：把Java对象转换为字节序列的过程。<br><strong>反序列化</strong>：把字节序列恢复为Java对象的过程。</p>
<p>用途：</p>
<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；（<strong>持久化对象</strong>）</li>
<li>在网络上传送对象的字节序列。（<strong>网络传输对象</strong>）</li>
</ul>
<h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h4><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
<pre><code class="java">public class MyRunnable implements Runnable
&#123;
    private volatile boolean active;
    public void run()
    &#123;
        active = true;
        while (active) // 第一行
        &#123;
            // 代码
        &#125;
    &#125;
    public void stop()
    &#123;
        active = false; // 第二行
    &#125;
&#125;
</code></pre>
<p>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 *<strong>第一行*</strong> 中缓冲区的 active 值被使用，那么在 *<strong>第二行*</strong> 的 active 值为 false 时循环不会停止。</p>
<p>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。</p>
<h2 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h2><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法 - 相加运算符两侧的值</td>
<td align="left">A + B 等于 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法 - 左操作数减去右操作数</td>
<td align="left">A – B 等于 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法 - 相乘操作符两侧的值</td>
<td align="left">A * B等于200</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法 - 左操作数除以右操作数</td>
<td align="left">B / A等于2</td>
</tr>
<tr>
<td align="left">％</td>
<td align="left">取余 - 左操作数除以右操作数的余数</td>
<td align="left">B%A等于0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增: 操作数的值增加1</td>
<td align="left">B++ 或 ++B 等于 21（区别详见下文）</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减: 操作数的值减少1</td>
<td align="left">B– 或 –B 等于 19（区别详见下文）</td>
</tr>
</tbody></table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">（A == B）为假。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td align="left">(A != B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td align="left">（A&gt; B）为假。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td align="left">（A &lt;B）为真。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td align="left">（A&gt; = B）为假。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td align="left">（A &lt;= B）为真。</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算。下表列出了位运算符的基本运算,假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">＆</td>
<td align="left">如果相对应位都是1，则结果为1，否则为0</td>
<td align="left">（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td>
<td align="left">（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果相对应位值相同，则结果为0，否则为1</td>
<td align="left">（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td align="left">〜</td>
<td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td align="left">（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt;</td>
<td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td align="left">（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td align="left">| |</td>
<td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td align="left">（A | | B）为真。</td>
</tr>
<tr>
<td align="left">！</td>
<td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td align="left">！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<pre><code class="java">public class LuoJi&#123;
    public static void main(String[] args)&#123;
        int a = 5;//定义一个变量；
        boolean b = (a&lt;4)&amp;&amp;(a++&lt;10);
        System.out.println(&quot;使用短路逻辑运算符的结果为&quot;+b);
        System.out.println(&quot;a的结果为&quot;+a);
    &#125;//使用短路逻辑运算符的结果为false
//a的结果为5
&#125;
</code></pre>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下面是Java语言支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td align="left">C = A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td align="left">+ =</td>
<td align="left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td align="left">C + = A等价于C = C + A</td>
</tr>
<tr>
<td align="left">- =</td>
<td align="left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td align="left">C - = A等价于C = C - A</td>
</tr>
<tr>
<td align="left">* =</td>
<td align="left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td align="left">C * = A等价于C = C * A</td>
</tr>
<tr>
<td align="left">/ =</td>
<td align="left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td align="left">C / = A，C 与 A 同类型时等价于 C = C / A</td>
</tr>
<tr>
<td align="left">（％）=</td>
<td align="left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td align="left">C％= A等价于C = C％A</td>
</tr>
<tr>
<td align="left">&lt;&lt; =</td>
<td align="left">左移位赋值运算符</td>
<td align="left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt; =</td>
<td align="left">右移位赋值运算符</td>
<td align="left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">＆=</td>
<td align="left">按位与赋值运算符</td>
<td align="left">C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td align="left">^ =</td>
<td align="left">按位异或赋值操作符</td>
<td align="left">C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td align="left">| =</td>
<td align="left">按位或赋值操作符</td>
<td align="left">C | = 2等价于C = C | 2</td>
</tr>
</tbody></table>
<h3 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h3><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<pre><code class="java">variable x = (expression) ? value if true : value if false
</code></pre>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<pre><code class="java">( Object reference variable ) instanceof  (class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<pre><code class="javaa">String name = &quot;James&quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>
<h3 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h3><p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">操作符</th>
<th align="left">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] . (点操作符)</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">expr++ expr–</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">++expr –expr + - ～ ！</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘性</td>
<td align="left">* /％</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">加性</td>
<td align="left">+ -</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&gt; &gt;= &lt; &lt;=</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">== !=</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left">＆</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left">^</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">|</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left">&amp;&amp;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left">| |</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">？：</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">，</td>
<td align="left">左到右</td>
</tr>
</tbody></table>
<h2 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h2><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。</p>
<p>Java中有三种主要的循环结构：</p>
<ul>
<li><strong>while</strong> 循环</li>
<li><strong>do…while</strong> 循环</li>
<li><strong>for</strong> 循环</li>
<li>在Java5中引入了一种主要用于数组的增强型for循环。</li>
</ul>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<pre><code class="java">for(初始化; 布尔表达式; 更新) &#123;
    //代码语句
&#125;
</code></pre>
<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<h3 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p>Java 增强 for 循环语法格式如下:</p>
<pre><code class="java">for(声明语句 : 表达式)
&#123;
   //代码句子
&#125;
//实例
public class Test &#123;
   public static void main(String args[])&#123;
      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;
 
      for(int x : numbers )&#123;
         System.out.print( x );
         System.out.print(&quot;,&quot;);
      &#125;
      System.out.print(&quot;\n&quot;);
      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;
      for( String name : names ) &#123;
         System.out.print( name );
         System.out.print(&quot;,&quot;);
      &#125;
   &#125;
&#125;
</code></pre>
<p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h2 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句- if…else"></a>Java 条件语句- if…else</h2><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<p>if 语句的语法如下：</p>
<pre><code class="java">if(布尔表达式)
&#123;
   //如果布尔表达式为true将执行的语句
&#125;
//if...else if...else 语句
if(布尔表达式 1)&#123;
   //如果布尔表达式 1的值为true执行代码
&#125;else if(布尔表达式 2)&#123;
   //如果布尔表达式 2的值为true执行代码
&#125;else if(布尔表达式 3)&#123;
   //如果布尔表达式 3的值为true执行代码
&#125;else &#123;
   //如果以上布尔表达式都不为true执行代码
&#125;
//嵌套的 if…else 语句
if(布尔表达式 1)&#123;
   ////如果布尔表达式 1的值为true执行代码
   if(布尔表达式 2)&#123;
      ////如果布尔表达式 2的值为true执行代码
   &#125;
&#125;
</code></pre>
<h2 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h2><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p><strong>语法:</strong></p>
<p>switch case 语句语法格式如下：</p>
<pre><code class="java">switch(expression)&#123;
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
&#125;
</code></pre>
<p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p>
<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（break，判断是否继续输出，或是跳出判断。**可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<h2 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h2><p>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：<strong>byte、int、long、double</strong> 等。然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。</p>
<p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p>
<table>
<thead>
<tr>
<th align="left">包装类</th>
<th align="left">基本数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">Byte</td>
<td align="left">byte</td>
</tr>
<tr>
<td align="left">Short</td>
<td align="left">short</td>
</tr>
<tr>
<td align="left">Integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">Long</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">Character</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">Float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">Double</td>
<td align="left">double</td>
</tr>
</tbody></table>
<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>
<h3 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h3><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
<pre><code class="java">public class Test &#123;  
    public static void main (String []args)  
    &#123;  
        System.out.println(&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));  
        System.out.println(&quot;0度的余弦值：&quot; + Math.cos(0));  
        System.out.println(&quot;60度的正切值：&quot; + Math.tan(Math.PI/3));  
        System.out.println(&quot;1的反正切值： &quot; + Math.atan(1));  
        System.out.println(&quot;π/2的角度值：&quot; + Math.toDegrees(Math.PI/2));  
        System.out.println(Math.PI);  
    &#125;  
&#125;
</code></pre>
<h3 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h3><p>下面的表中列出的是 Number &amp; Math 类常用的一些方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-xxxvalue.html">xxxValue()</a> 将 Number 对象转换为xxx数据类型的值并返回。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-compareto.html">compareTo()</a> 将number对象与参数比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-equals.html">equals()</a> 判断number对象是否与参数相等。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-valueof.html">valueOf()</a> 返回一个 Number 对象指定的内置数据类型</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-tostring.html">toString()</a> 以字符串形式返回值。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-parseInt.html">parseInt()</a> 将字符串解析为int类型。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-abs.html">abs()</a> 返回参数的绝对值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-ceil.html">ceil()</a> 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-floor.html">floor()</a> 返回小于等于（&lt;=）给定参数的最大整数 。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-rint.html">rint()</a> 返回与参数最接近的整数。返回类型为double。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-round.html">round()</a> 它表示<strong>四舍五入</strong>，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-min.html">min()</a> 返回两个参数中的最小值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-max.html">max()</a> 返回两个参数中的最大值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-exp.html">exp()</a> 返回自然数底数e的参数次方。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-log.html">log()</a> 返回参数的自然数底数的对数值。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-pow.html">pow()</a> 返回第一个参数的第二个参数次方。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-sqrt.html">sqrt()</a> 求参数的算术平方根。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-sin.html">sin()</a> 求指定double类型参数的正弦值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-cos.html">cos()</a> 求指定double类型参数的余弦值。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-tan.html">tan()</a> 求指定double类型参数的正切值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-asin.html">asin()</a> 求指定double类型参数的反正弦值。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-acos.html">acos()</a> 求指定double类型参数的反余弦值。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-atan.html">atan()</a> 求指定double类型参数的反正切值。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-atan2.html">atan2()</a> 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-todegrees.html">toDegrees()</a> 将参数转化为角度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-toradians.html">toRadians()</a> 将角度转换为弧度。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-random.html">random()</a> 返回一个随机数。</td>
</tr>
</tbody></table>
<h2 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h2><p>Character 类用于对单个字符进行操作。</p>
<p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值</p>
<pre><code class="java">char ch = &#39;a&#39;;
 
// Unicode 字符表示形式
char uniChar = &#39;\u039A&#39;; 
 
// 字符数组
char[] charArray =&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; &#125;;
</code></pre>
<p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p>
<p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：</p>
<pre><code class="java">Character ch = new Character(&#39;a&#39;);
</code></pre>
<p>在某些情况下，Java编译器会自动创建一个Character对象。</p>
<p>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p>
<pre><code class="java">// 原始字符 &#39;a&#39; 装箱到 Character 对象 ch 中
Character ch = &#39;a&#39;;
 
// 原始字符 &#39;x&#39; 用 test 方法装箱
// 返回拆箱的值到 &#39;c&#39;
char c = test(&#39;x&#39;);
</code></pre>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\t</td>
<td align="left">在文中该处插入一个tab键</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">在文中该处插入一个后退键</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">在文中该处换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">在文中该处插入回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">在文中该处插入换页符</td>
</tr>
<tr>
<td align="left">\‘</td>
<td align="left">在文中该处插入单引号</td>
</tr>
<tr>
<td align="left">\“</td>
<td align="left">在文中该处插入双引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">在文中该处插入反斜杠</td>
</tr>
</tbody></table>
<h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isletter.html">isLetter()</a> 是否是一个字母</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a> 是否是一个数字字符</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a> 是否是一个空白字符</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a> 是否是大写字母</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a> 是否是小写字母</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a> 指定字母的大写形式</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>() 指定字母的小写形式</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-tostring.html">toString</a>() 返回字符的字符串形式，字符串的长度仅为1</td>
</tr>
</tbody></table>
<h2 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h2><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p>
<p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p>
<pre><code class="java">String str = &quot;Runoob&quot;;
String str2=new String(&quot;Runoob&quot;);
String s1 = &quot;Runoob&quot;;              // String 直接创建
String s2 = &quot;Runoob&quot;;              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String(&quot;Runoob&quot;);   // String 对象创建
String s5 = new String(&quot;Runoob&quot;);   // String 对象创建
//String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提
//供一个字符数组参数:
char[] helloArray = &#123; &#39;r&#39;, &#39;u&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;b&#39;&#125;;
String helloString = new String(helloArray);  
</code></pre>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png"></p>
<h3 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a>String、StringBuffer 和 StringBuilder 的区别</h3><p><strong>String</strong>：字符串常量，字符串长度不可变。Java中String 是immutable（不可变）的。用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p>
<p><strong>StringBuffer</strong>：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。Java.lang.StringBuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</p>
<p><strong>StringBuilder</strong>：字符串变量（非线程安全）。在内部 StringBuilder 对象被当作是一个包含字符序列的变长数组。</p>
<p><strong>基本原则：</strong></p>
<ul>
<li>如果要操作少量的数据用 String ；</li>
<li>单线程操作大量数据用StringBuilder ；</li>
<li>多线程操作大量数据，用StringBuffer。</li>
<li>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了.如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</li>
</ul>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>用于获取有关对象的信息的方法称为访问器方法。</p>
<p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p>
<p>length() 方法，length 属性和 size() 方法的区别:</p>
<ul>
<li> 1、<strong>length()</strong> 方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</li>
<li> 2、<strong>length 属性</strong>是针对 Java 中的数组来说的，要求数组的长度可以用其 length 属性；</li>
<li> 3、Java 中的 <strong>size()</strong> 方法是针对泛型集合说的, 如果想看这个泛型有多少个元素, 就调用此方法来查看!</li>
</ul>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String 类提供了连接两个字符串的方法：</p>
<pre><code class="java">string1.concat(string2);
//返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：
&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);
//更常用的是使用&#39;+&#39;操作符来连接字符串，如：
&quot;Hello,&quot; + &quot; runoob&quot; + &quot;!&quot;
</code></pre>
<h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p>
<p>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。</p>
<p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p>
<pre><code class="java">System.out.printf(&quot;浮点型变量的值为 &quot; +
                  &quot;%f, 整型变量的值为 &quot; +
                  &quot; %d, 字符串变量的值为 &quot; +
                  &quot;is %s&quot;, floatVar, intVar, stringVar);
String fs;
fs = String.format(&quot;浮点型变量的值为 &quot; +
                   &quot;%f, 整型变量的值为 &quot; +
                   &quot; %d, 字符串变量的值为 &quot; +
                   &quot; %s&quot;, floatVar, intVar, stringVar);
</code></pre>
<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><table>
<thead>
<tr>
<th align="left">SN(序号)</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">[void getChars(int srcBegin, int srcEnd, char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getchars.html">] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">[char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tochararray.html">] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td>
</tr>
</tbody></table>
<h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-20201208.png"></p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
<h3 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">insert(int offset, String str) 将 <code>str</code> 参数的字符串插入此序列中。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">int capacity() 返回当前容量。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">char charAt(int index) 返回此序列中指定索引处的 <code>char</code> 值。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 <code>dst</code>。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">int length()  返回长度（字符数）。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">void setCharAt(int index, char ch) 将给定索引处的字符设置为 <code>ch</code>。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void setLength(int newLength) 设置字符序列的长度。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">String substring(int start) 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">String toString() 返回此序列中数据的字符串表示形式。</td>
</tr>
</tbody></table>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<pre><code class="java">dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
//创建数组
//Java语言使用new操作符来创建数组，语法如下：
arrayRefVar = new dataType[arraySize];
//使用 dataType[arraySize] 创建了一个数组。
//把新创建的数组的引用赋值给变量 arrayRefVar。
//数组变量的声明，和创建数组可以用一条语句完成
dataType[] arrayRefVar = new dataType[arraySize];
</code></pre>
<h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><pre><code class="java">1. 直接为每一维分配空间，格式如下：
type[][] typeName = new type[typeLength1][typeLength2];
2. 从最高维开始，分别为每一维分配空间，例如：
String s[][] = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String(&quot;Good&quot;);
s[0][1] = new String(&quot;Luck&quot;);
s[1][0] = new String(&quot;to&quot;);
s[1][1] = new String(&quot;you&quot;);
s[1][2] = new String(&quot;!&quot;);
</code></pre>
<h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h3 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h3><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p>
<pre><code class="java">//第一个构造函数使用当前日期和时间来初始化对象。
Date( )
//第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。
Date(long millisec)
</code></pre>
<p>Date对象创建以后，可以调用下面的方法。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>Object clone( )</strong> 返回此对象的副本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</td>
</tr>
</tbody></table>
<pre><code class="java">//获取当前日期时间
import java.util.Date;
  
public class DateDemo &#123;
   public static void main(String args[]) &#123;
       // 初始化 Date 对象
       Date date = new Date();
        
       // 使用 toString() 函数显示日期时间
       System.out.println(date.toString());
   &#125;
&#125;
</code></pre>
<h3 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h3><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：</p>
<pre><code class="java">import  java.util.*;
import java.text.*;
 
public class DateDemo &#123;
   public static void main(String args[]) &#123;
 
      Date dNow = new Date( );
      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);//当前时间为: 2018-09-06 10:16:34
      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));
   &#125;
&#125;
//注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。
</code></pre>
<h4 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h4><p>时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>字母</strong></th>
<th align="left"><strong>描述</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">G</td>
<td align="left">纪元标记</td>
<td align="left">AD</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">四位年份</td>
<td align="left">2001</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">月份</td>
<td align="left">July or 07</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">一个月的日期</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">A.M./P.M. (1~12)格式小时</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">H</td>
<td align="left">一天中的小时 (0~23)</td>
<td align="left">22</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">分钟数</td>
<td align="left">30</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">秒数</td>
<td align="left">55</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">毫秒数</td>
<td align="left">234</td>
</tr>
<tr>
<td align="left">E</td>
<td align="left">星期几</td>
<td align="left">Tuesday</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">一年中的日子</td>
<td align="left">360</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">一个月中第几周的周几</td>
<td align="left">2 (second Wed. in July)</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">一年中第几周</td>
<td align="left">40</td>
</tr>
<tr>
<td align="left">W</td>
<td align="left">一个月中第几周</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">A.M./P.M. 标记</td>
<td align="left">PM</td>
</tr>
<tr>
<td align="left">k</td>
<td align="left">一天中的小时(1~24)</td>
<td align="left">24</td>
</tr>
<tr>
<td align="left">K</td>
<td align="left">A.M./P.M. (0~11)格式小时</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">z</td>
<td align="left">时区</td>
<td align="left">Eastern Standard Time</td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">文字定界符</td>
<td align="left">Delimiter</td>
</tr>
<tr>
<td align="left">“</td>
<td align="left">单引号</td>
<td align="left">`</td>
</tr>
</tbody></table>
<h3 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h3><p>printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<table>
<thead>
<tr>
<th align="left">转 换 符</th>
<th align="left">说  明</th>
<th align="left">示  例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c</td>
<td align="left">包括全部日期和时间信息</td>
<td align="left">星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">“年-月-日”格式</td>
<td align="left">2007-10-27</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">“月/日/年”格式</td>
<td align="left">10/27/07</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">“HH:MM:SS PM”格式（12时制）</td>
<td align="left">02:25:51 下午</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">“HH:MM:SS”格式（24时制）</td>
<td align="left">14:28:16</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">“HH:MM”格式（24时制）</td>
<td align="left">14:28</td>
</tr>
</tbody></table>
<pre><code class="java">Date date = new Date();
//c的使用  全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  
System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          
//f的使用  年-月-日格式：2012-09-10  
System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  
//d的使用  月/日/年格式：09/10/12  
System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  
//r的使用  HH:MM:SS PM格式（12时制）：10:43:36 上午  
System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  
//t的使用  HH:MM:SS格式（24时制）：10:43:36  
System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  
//R的使用  HH:MM格式（24时制）：10:43  
System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  
</code></pre>
<h3 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h3><pre><code class="java">//下面的一个例子表明如何测量时间间隔（以毫秒为单位）：
import java.util.*;
public class DiffDemo &#123;
 
   public static void main(String args[]) &#123;
      try &#123;
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + &quot;\n&quot;);
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + &quot;\n&quot;);
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println(&quot;Difference is : &quot; + diff);
      &#125; catch (Exception e) &#123;
         System.out.println(&quot;Got an exception!&quot;);
      &#125;
   &#125;
&#125;
</code></pre>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p>
<p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p>
<pre><code class="java">//创建一个代表系统当前日期的Calendar对象
Calendar c = Calendar.getInstance();//默认是当前日期
</code></pre>
<p>创建一个指定日期的Calendar对象</p>
<p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p>
<pre><code class="java">//创建一个代表2009年6月12日的Calendar对象
Calendar c1 = Calendar.getInstance();
c1.set(2009, 6 , 12);
</code></pre>
<h4 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h4><p>Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Calendar.YEAR</td>
<td align="left">年份</td>
</tr>
<tr>
<td align="left">Calendar.MONTH</td>
<td align="left">月份</td>
</tr>
<tr>
<td align="left">Calendar.DATE</td>
<td align="left">日期</td>
</tr>
<tr>
<td align="left">Calendar.DAY_OF_MONTH</td>
<td align="left">日期，和上面的字段意义完全相同</td>
</tr>
<tr>
<td align="left">Calendar.HOUR</td>
<td align="left">12小时制的小时</td>
</tr>
<tr>
<td align="left">Calendar.HOUR_OF_DAY</td>
<td align="left">24小时制的小时</td>
</tr>
<tr>
<td align="left">Calendar.MINUTE</td>
<td align="left">分钟</td>
</tr>
<tr>
<td align="left">Calendar.SECOND</td>
<td align="left">秒</td>
</tr>
<tr>
<td align="left">Calendar.DAY_OF_WEEK</td>
<td align="left">星期几</td>
</tr>
</tbody></table>
<pre><code class="java">Calendar c1 = Calendar.getInstance();
c1.set(2009, 6, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12
//把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算
c1.set(Calendar.DATE,10);
//把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算
c1.set(Calendar.YEAR,2008);
</code></pre>
<h4 id="Add设置"><a href="#Add设置" class="headerlink" title="Add设置"></a><strong>Add设置</strong></h4><pre><code class="java">Calendar c1 = Calendar.getInstance();
//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算
c1.add(Calendar.DATE, 10);
//把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算
c1.add(Calendar.DATE, -10);
//其他字段属性的add的意义以此类推
</code></pre>
<h4 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h4><pre><code class="java">Calendar c1 = Calendar.getInstance();
// 获得年份
int year = c1.get(Calendar.YEAR);
// 获得月份
int month = c1.get(Calendar.MONTH) + 1;
// 获得日期
int date = c1.get(Calendar.DATE);
// 获得小时
int hour = c1.get(Calendar.HOUR_OF_DAY);
// 获得分钟
int minute = c1.get(Calendar.MINUTE);
// 获得秒
int second = c1.get(Calendar.SECOND);
// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）
int day = c1.get(Calendar.DAY_OF_WEEK);
</code></pre>
<h3 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p>
<p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。</p>
<p>下面列出GregorianCalendar对象的几个构造方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>构造函数和说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>GregorianCalendar()</strong> 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。</td>
</tr>
<tr>
<td>2</td>
<td><strong>GregorianCalendar(int year, int month, int date)</strong> 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar</td>
</tr>
<tr>
<td>3</td>
<td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute)</strong> 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td>
</tr>
<tr>
<td>4</td>
<td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute, int second)</strong>  为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td>
</tr>
<tr>
<td>5</td>
<td><strong>GregorianCalendar(Locale aLocale)</strong> 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。</td>
</tr>
<tr>
<td>6</td>
<td><strong>GregorianCalendar(TimeZone zone)</strong> 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td>
</tr>
<tr>
<td>7</td>
<td><strong>GregorianCalendar(TimeZone zone, Locale aLocale)</strong>  在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td>
</tr>
</tbody></table>
<p>这里是GregorianCalendar 类提供的一些有用的方法列表：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法和说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>void add(int field, int amount)</strong> 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。</td>
</tr>
<tr>
<td>2</td>
<td><strong>protected void computeFields()</strong> 转换UTC毫秒值为时间域值</td>
</tr>
<tr>
<td>3</td>
<td><strong>protected void computeTime()</strong> 覆盖Calendar ，转换时间域值为UTC毫秒值</td>
</tr>
<tr>
<td>4</td>
<td><strong>boolean equals(Object obj)</strong> 比较此 GregorianCalendar 与指定的 Object。</td>
</tr>
<tr>
<td>5</td>
<td><strong>int get(int field)</strong> 获取指定字段的时间值</td>
</tr>
<tr>
<td>6</td>
<td><strong>int getActualMaximum(int field)</strong> 返回当前日期，给定字段的最大值</td>
</tr>
<tr>
<td>7</td>
<td><strong>int getActualMinimum(int field)</strong> 返回当前日期，给定字段的最小值</td>
</tr>
<tr>
<td>8</td>
<td><strong>int getGreatestMinimum(int field)</strong>  返回此 GregorianCalendar 实例给定日历字段的最高的最小值。</td>
</tr>
<tr>
<td>9</td>
<td><strong>Date getGregorianChange()</strong> 获得格里高利历的更改日期。</td>
</tr>
<tr>
<td>10</td>
<td><strong>int getLeastMaximum(int field)</strong> 返回此 GregorianCalendar 实例给定日历字段的最低的最大值</td>
</tr>
<tr>
<td>11</td>
<td><strong>int getMaximum(int field)</strong> 返回此 GregorianCalendar 实例的给定日历字段的最大值。</td>
</tr>
<tr>
<td>12</td>
<td><strong>Date getTime()</strong> 获取日历当前时间。</td>
</tr>
<tr>
<td>13</td>
<td><strong>long getTimeInMillis()</strong> 获取用长整型表示的日历的当前时间</td>
</tr>
<tr>
<td>14</td>
<td><strong>TimeZone getTimeZone()</strong> 获取时区。</td>
</tr>
<tr>
<td>15</td>
<td><strong>int getMinimum(int field)</strong> 返回给定字段的最小值。</td>
</tr>
<tr>
<td>16</td>
<td><strong>int hashCode()</strong> 重写hashCode.</td>
</tr>
<tr>
<td>17</td>
<td><strong>boolean isLeapYear(int year)</strong> 确定给定的年份是否为闰年。</td>
</tr>
<tr>
<td>18</td>
<td><strong>void roll(int field, boolean up)</strong> 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</td>
</tr>
<tr>
<td>19</td>
<td><strong>void set(int field, int value)</strong> 用给定的值设置时间字段。</td>
</tr>
<tr>
<td>20</td>
<td><strong>void set(int year, int month, int date)</strong> 设置年、月、日的值。</td>
</tr>
<tr>
<td>21</td>
<td><strong>void set(int year, int month, int date, int hour, int minute)</strong> 设置年、月、日、小时、分钟的值。</td>
</tr>
<tr>
<td>22</td>
<td><strong>void set(int year, int month, int date, int hour, int minute, int second)</strong> 设置年、月、日、小时、分钟、秒的值。</td>
</tr>
<tr>
<td>23</td>
<td><strong>void setGregorianChange(Date date)</strong> 设置 GregorianCalendar 的更改日期。</td>
</tr>
<tr>
<td>24</td>
<td><strong>void setTime(Date date)</strong> 用给定的日期设置Calendar的当前时间。</td>
</tr>
<tr>
<td>25</td>
<td><strong>void setTimeInMillis(long millis)</strong> 用给定的long型毫秒数设置Calendar的当前时间。</td>
</tr>
<tr>
<td>26</td>
<td><strong>void setTimeZone(TimeZone value)</strong> 用给定时区值设置当前时区。</td>
</tr>
<tr>
<td>27</td>
<td><strong>String toString()</strong> 返回代表日历的字符串。</td>
</tr>
</tbody></table>
<h2 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h2><p>正则表达式定义了字符串的模式。</p>
<p>正则表达式可以用来搜索、编辑或处理文本。</p>
<p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。一个字符串其实就是一个简单的正则表达式，例如 <strong>Hello World</strong> 正则表达式匹配 “Hello World” 字符串。</p>
<p>**.**（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。</p>
<p>下表列出了一些正则表达式的实例及描述：</p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">this is text</td>
<td align="left">匹配字符串 “this is text”</td>
</tr>
<tr>
<td align="left">this\s+is\s+text</td>
<td align="left">注意字符串中的 **\s+**。匹配单词 “this” 后面的 <strong>\s+</strong> 可以匹配多个空格，之后匹配 is 字符串，再之后 <strong>\s+</strong> 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td>
</tr>
<tr>
<td align="left">^\d+(.\d+)?</td>
<td align="left">^ 定义了以什么开始\d+ 匹配一个或多个数字? 设置括号内的选项是可选的. 匹配 “.”可以匹配的实例：”5”, “1.5” 和 “2.21”。</td>
</tr>
</tbody></table>
<p>Java 正则表达式和 Perl 的是最为相似的。</p>
<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p><strong>Pattern 类：</strong></p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
</li>
<li><p><strong>Matcher 类：</strong></p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
</li>
<li><p><strong>PatternSyntaxException：</strong></p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<pre><code class="java">import java.util.regex.*;
 
class RegexExample1&#123;
   public static void main(String[] args)&#123;
      String content = &quot;I am noob &quot; +
        &quot;from runoob.com.&quot;;
 
      String pattern = &quot;.*runoob.*&quot;;
 
      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch);
   &#125;
&#125;
</code></pre>
<h3 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h3><p>捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
&#123;
    public static void main( String[] args )&#123;
 
      // 按指定模式在字符串查找
      String line = &quot;This order was placed for QT3000! OK?&quot;;
      String pattern = &quot;(\\D*)(\\d+)(.*)&quot;;
 
      // 创建 Pattern 对象
      Pattern r = Pattern.compile(pattern);
 
      // 现在创建 matcher 对象
      Matcher m = r.matcher(line);
      if (m.find( )) &#123;
         System.out.println(&quot;Found value: &quot; + m.group(0) );
         System.out.println(&quot;Found value: &quot; + m.group(1) );
         System.out.println(&quot;Found value: &quot; + m.group(2) );
         System.out.println(&quot;Found value: &quot; + m.group(3) ); 
      &#125; else &#123;
         System.out.println(&quot;NO MATCH&quot;);
      &#125;
   &#125;
&#125;
</code></pre>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>在 Java 中，<strong>\** 表示：</strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。**</p>
<p>所以，在其他的语言中（如 Perl），一个反斜杠 *<em>*</em> 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 *<em>\*</em> 代表其他语言中的一个 ****，这也就是为什么表示一位数字的正则表达式是 <strong>\d</strong>，而表示一个普通的反斜杠是 **\**。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong>n</strong>匹配字符 <strong>n</strong>。<strong>\n</strong> 匹配换行符。序列 <strong>\\** 匹配 *<em>\*</em> ，</strong>\(** 匹配 **(**。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td align="left">{<em>n</em>}</td>
<td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,}</td>
<td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,<em>m</em>}</td>
<td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="left">(<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td>
</tr>
<tr>
<td align="left">(?:<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td>
</tr>
<tr>
<td align="left">(?=<em>pattern</em>)</td>
<td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left">(?!<em>pattern</em>)</td>
<td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left"><em>x</em>|<em>y</em></td>
<td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td align="left">[<em>xyz</em>]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="left">[^<em>xyz</em>]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="left">[<em>a-z</em>]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="left">[^<em>a-z</em>]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="left">\c<em>x</em></td>
<td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\x<em>n</em></td>
<td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="left">*num*</td>
<td align="left">匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="left">*n*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td>
</tr>
<tr>
<td align="left">*nm*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="left">\nml</td>
<td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td>
</tr>
<tr>
<td align="left">\u<em>n</em></td>
<td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<h3 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h3><h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public int start()</strong> 返回以前匹配的初始索引。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td>
</tr>
</tbody></table>
<h4 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h4><p>查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public boolean lookingAt()</strong>  尝试将从区域开头开始的输入序列与该模式匹配。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public boolean find(int start****）</strong> 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public boolean matches()</strong> 尝试将整个区域与模式匹配。</td>
</tr>
</tbody></table>
<h4 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h4><table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public String replaceAll(String replacement)</strong>  替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td>
</tr>
</tbody></table>
<pre><code class="java">//start 和 end 方法
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
&#123;
    private static final String REGEX = &quot;\\bcat\\b&quot;;//使用单词边界，以确保字母 &quot;c&quot; &quot;a&quot; &quot;t&quot; 并非仅是一个较长的词的子串。
    private static final String INPUT =
                                    &quot;cat cat cat cattie cat&quot;;
 
    public static void main( String[] args )&#123;
       Pattern p = Pattern.compile(REGEX);
       Matcher m = p.matcher(INPUT); // 获取 matcher 对象
       int count = 0;
 
       while(m.find()) &#123;
         count++;
         System.out.println(&quot;Match number &quot;+count);
         System.out.println(&quot;start(): &quot;+m.start());
         System.out.println(&quot;end(): &quot;+m.end());
      &#125;
   &#125;
&#125;
/**输出
Match number 1
start(): 0
end(): 3
Match number 2
start(): 4
end(): 7
Match number 3
start(): 8
end(): 11
Match number 4
start(): 19
end(): 22*/
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>不差钱的大哥哥大姐姐可以点一点扫一扫</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="ZQY 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="ZQY 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/21/%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/" rel="prev" title="基于opencv的视频监控系统">
      <i class="fa fa-chevron-left"></i> 基于opencv的视频监控系统
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzAxMy8yOTQ4OQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1"><span class="nav-number">1.</span> <span class="nav-text">Java 学习笔记(1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.1.1.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE"><span class="nav-number">1.1.2.</span> <span class="nav-text">JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK"><span class="nav-number">1.1.3.</span> <span class="nav-text">JDK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">JAVA基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Java修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Java 标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">Java 变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">Java 数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">Java 枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%B3%A8%E9%87%8A"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">Java注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%90%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.9.</span> <span class="nav-text">Java 源程序与编译型运行区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">Java 对象和类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">访问实例变量和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99"><span class="nav-number">1.3.4.</span> <span class="nav-text">源文件声明规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">Java基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">内置数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">Java 常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">自动类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">Java变量类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">Java局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">类变量（静态变量）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.</span> <span class="nav-text">Java 修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.1.</span> <span class="nav-text">访问控制修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.</span> <span class="nav-text">访问控制和继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.</span> <span class="nav-text">非访问修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">static 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">final 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">abstract 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">synchronized 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transient-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">transient 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.6.3.6.</span> <span class="nav-text">volatile 修饰符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.</span> <span class="nav-text">Java 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.3.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.4.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.5.</span> <span class="nav-text">短路逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.6.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-number">1.7.7.</span> <span class="nav-text">条件运算符（?:）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.8.</span> <span class="nav-text">instanceof 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.7.9.</span> <span class="nav-text">Java运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-for-while-%E5%8F%8A-do%E2%80%A6while"><span class="nav-number">1.8.</span> <span class="nav-text">Java 循环结构 - for, while 及 do…while</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.8.1.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.8.2.</span> <span class="nav-text">Java 增强 for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.3.</span> <span class="nav-text">break 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continue-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.4.</span> <span class="nav-text">continue 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-if%E2%80%A6else"><span class="nav-number">1.9.</span> <span class="nav-text">Java 条件语句- if…else</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-switch-case-%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.10.</span> <span class="nav-text">Java switch case 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Number-amp-Math-%E7%B1%BB"><span class="nav-number">1.11.</span> <span class="nav-text">Java Number &amp; Math 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Math-%E7%B1%BB"><span class="nav-number">1.11.1.</span> <span class="nav-text">Java Math 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-amp-Math-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.2.</span> <span class="nav-text">Number &amp; Math 类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Character-%E7%B1%BB"><span class="nav-number">1.12.</span> <span class="nav-text">Java Character 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="nav-number">1.12.1.</span> <span class="nav-text">转义序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Character-%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.2.</span> <span class="nav-text">Character 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-String-%E7%B1%BB"><span class="nav-number">1.13.</span> <span class="nav-text">Java String 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.1.</span> <span class="nav-text">String、StringBuffer 和 StringBuilder 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-number">1.13.2.</span> <span class="nav-text">字符串长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.13.3.</span> <span class="nav-text">连接字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.13.4.</span> <span class="nav-text">创建格式化字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E6%96%B9%E6%B3%95"><span class="nav-number">1.13.5.</span> <span class="nav-text">String 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-StringBuffer-%E5%92%8C-StringBuilder-%E7%B1%BB"><span class="nav-number">1.14.</span> <span class="nav-text">Java StringBuffer 和 StringBuilder 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer-%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.1.</span> <span class="nav-text">StringBuffer 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E6%95%B0%E7%BB%84"><span class="nav-number">1.15.</span> <span class="nav-text">Java数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.15.1.</span> <span class="nav-text">声明数组变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-number">1.15.2.</span> <span class="nav-text">多维数组的动态初始化（以二维数组为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-%E7%B1%BB"><span class="nav-number">1.15.3.</span> <span class="nav-text">Arrays 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">1.15.4.</span> <span class="nav-text">Java 日期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="nav-number">1.15.5.</span> <span class="nav-text">使用 SimpleDateFormat 格式化日期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BC%96%E7%A0%81"><span class="nav-number">1.15.5.1.</span> <span class="nav-text">日期和时间的格式化编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="nav-number">1.15.6.</span> <span class="nav-text">使用printf格式化日期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E6%97%B6%E9%97%B4"><span class="nav-number">1.15.7.</span> <span class="nav-text">测量时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calendar%E7%B1%BB"><span class="nav-number">1.15.8.</span> <span class="nav-text">Calendar类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Calendar%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.8.1.</span> <span class="nav-text">Calendar类对象字段类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Add%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.15.8.2.</span> <span class="nav-text">Add设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Calendar%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%BE%97"><span class="nav-number">1.15.8.3.</span> <span class="nav-text">Calendar类对象信息的获得</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GregorianCalendar%E7%B1%BB"><span class="nav-number">1.15.9.</span> <span class="nav-text">GregorianCalendar类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.16.</span> <span class="nav-text">Java正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="nav-number">1.16.1.</span> <span class="nav-text">捕获组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">1.16.2.</span> <span class="nav-text">正则表达式语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Matcher-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.3.</span> <span class="nav-text">Matcher 类的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">索引方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.3.2.</span> <span class="nav-text">查找方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.3.3.</span> <span class="nav-text">替换方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQY"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ZQY</p>
  <div class="site-description" itemprop="description">ZQY的博客 |   每一个不曾起舞的日子，都是对生命的辜负。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zqy000" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zqy000" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2365626817@qq.com" title="E-Mail → mailto:2365626817@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQY</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="200" alpha="0.6" zIndex="-2" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
